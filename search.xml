<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[jQuery夜晚天空满天星星闪烁动画（附源码）]]></title>
      <url>/2018/06/20/jQuery%E5%A4%9C%E6%99%9A%E5%A4%A9%E7%A9%BA%E6%BB%A1%E5%A4%A9%E6%98%9F%E6%98%9F%E9%97%AA%E7%83%81%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>夜空星星萤火虫背景动画效果代码</p>
<a id="more"></a>
<h3 id="萤火虫星空效果图"><a href="#萤火虫星空效果图" class="headerlink" title="萤火虫星空效果图"></a>萤火虫星空效果图</h3><p><a href="http://appzy.vip/images/Totoroview.gif"><img src="http://appzy.vip/images/Totoroview.gif"></a> </p>
<p><a href="http://en.jsrun.net/7GYKp" target="_blank" rel="noopener">在线查看</a></p>
<p><a href="http://en.jsrun.net/7GYKp/edit" target="_blank" rel="noopener">在线编辑</a></p>
<h3 id="背景星星效果图"><a href="#背景星星效果图" class="headerlink" title="背景星星效果图"></a>背景星星效果图</h3><p><a href="http://appzy.vip/images/Totoro.gif"><img src="http://appzy.vip/images/Totoro.gif"></a> </p>
<p><a href="http://en.jsrun.net/D2qKp" target="_blank" rel="noopener">在线查看</a></p>
<p><a href="http://en.jsrun.net/D2qKp/edit" target="_blank" rel="noopener">在线编辑</a></p>
<h3 id="萤火虫星空CSS样式"><a href="#萤火虫星空CSS样式" class="headerlink" title="萤火虫星空CSS样式"></a>萤火虫星空CSS样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">* &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  background: #22313f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#starsBox &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  background: rgba(0, 0, 0, 0.75);</span><br><span class="line">  opacity: .85;</span><br><span class="line">&#125;</span><br><span class="line">#starsBox span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: auto;</span><br><span class="line">  position: absolute;</span><br><span class="line">  border-radius: 100%;</span><br><span class="line">  transition: 100s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  text-align: center;</span><br><span class="line">  transform: translateY(-50%);</span><br><span class="line">  font-size: 40px;</span><br><span class="line">  font-weight: 900;</span><br><span class="line">  color: white;</span><br><span class="line">  text-shadow: 0 0 50px black;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">  font-family: &apos;Roboto&apos;,&apos;Helvetica&apos;,&apos;Arial&apos;,sans-serif;</span><br><span class="line">  letter-spacing: 5px;</span><br><span class="line">&#125;</span><br><span class="line">p &gt; span &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">  color: #bdc3c7;</span><br><span class="line">  margin-top: 30px;</span><br><span class="line">  font-weight: 100;</span><br><span class="line">  text-shadow: 0 0 50px black;</span><br><span class="line">  letter-spacing: 3px;</span><br><span class="line">&#125;</span><br><span class="line">p &gt; span &gt; a &#123;</span><br><span class="line">  font-weight: 700;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  color: #d64541;</span><br><span class="line">  padding-bottom: 2px;</span><br><span class="line">  border-bottom: 0px solid #d64541;</span><br><span class="line">  transition: 0.5s;</span><br><span class="line">&#125;</span><br><span class="line">p &gt; span &gt; a:hover &#123;</span><br><span class="line">  padding-bottom: 5px;</span><br><span class="line">  border-bottom: 2px solid #d64541;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="萤火虫星空JavaScript动画代码"><a href="#萤火虫星空JavaScript动画代码" class="headerlink" title="萤火虫星空JavaScript动画代码"></a>萤火虫星空JavaScript动画代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var cols = [&apos;#f5d76e&apos;,&apos;#f7ca18&apos;,&apos;#f4d03f&apos;,&apos;#ececec&apos;,&apos;#ecf0f1&apos;,&apos;#a2ded0&apos;];</span><br><span class="line">var stars = 500;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt;= stars; i++) &#123;</span><br><span class="line"></span><br><span class="line">	var size = Math.random()*5;</span><br><span class="line">  var color = cols[parseInt(Math.random()*4)];</span><br><span class="line"></span><br><span class="line">	$(&apos;#starsBox&apos;).prepend(&apos;&lt;span style=&quot; width: &apos; + size + &apos;px; height: &apos; + size + &apos;px; top: &apos; + Math.random()*100 + &apos;%; left: &apos; + Math.random()*100 + &apos;%; background: &apos; + color + &apos;; box-shadow: 0 0 &apos;+ Math.random()*10 +&apos;px&apos; + color + &apos;;&quot;&gt;&lt;/span&gt;&apos;) ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123; </span><br><span class="line">	$(&apos;#starsBox span&apos;).each(function()&#123;  </span><br><span class="line"> 		$(this).css(&apos;top&apos;, Math.random()*100 + &apos;%&apos;).css(&apos;left&apos;, Math.random()*100 + &apos;%&apos;); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1);</span><br><span class="line"></span><br><span class="line">setInterval(function()&#123; </span><br><span class="line">	$(&apos;#starsBox span&apos;).each(function()&#123;  	</span><br><span class="line"> 		$(this).css(&apos;top&apos;, Math.random()*100 + &apos;%&apos;).css(&apos;left&apos;, Math.random()*100 + &apos;%&apos;); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 100000);</span><br></pre></td></tr></table></figure>
<h3 id="背景星星JavaScript代码"><a href="#背景星星JavaScript代码" class="headerlink" title="背景星星JavaScript代码"></a>背景星星JavaScript代码</h3><p>源码是经过babel 编译的</p>
<p>如果你的浏览器不支持的话</p>
<p><a href="http://babeljs.io/repl/" target="_blank" rel="noopener">bable在线编译</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  const star_png = &apos;http://flowpp.com:8080/img/star.png&apos;</span><br><span class="line">  const ICON_SIZE = 7</span><br><span class="line">  const ICON_NUM = 7</span><br><span class="line">  const star_num = 300</span><br><span class="line"></span><br><span class="line">  class Start &#123;</span><br><span class="line">      constructor (star, rect) &#123;</span><br><span class="line">          this.star = star</span><br><span class="line">          this.init(rect)</span><br><span class="line">      &#125;</span><br><span class="line">      init (rect) &#123;</span><br><span class="line">          this.rect = rect || this.rect</span><br><span class="line">          this.index = Math.random() * ICON_NUM | 0</span><br><span class="line">          this.x = Math.random() * this.rect.width</span><br><span class="line">          this.xSpd = Math.random() * 0.04 - 0.02</span><br><span class="line">          this.y = Math.random() * this.rect.height</span><br><span class="line">          this.alpha = Math.sin(Math.random() * Math.PI * 2)</span><br><span class="line">          this.timer = 0</span><br><span class="line">      &#125;</span><br><span class="line">      draw (ctx) &#123;</span><br><span class="line">          ctx.save()</span><br><span class="line">          ctx.globalAlpha = this.alpha * 0.2</span><br><span class="line">          ctx.drawImage(this.star, this.index * ICON_NUM, 0, ICON_SIZE, ICON_SIZE, this.x, this.y, ICON_SIZE, ICON_SIZE)</span><br><span class="line">          ctx.restore()</span><br><span class="line">      &#125;</span><br><span class="line">      update () &#123;</span><br><span class="line">          this.x += this.xSpd</span><br><span class="line">          if (this.x &gt; this.rect.width || this.x &lt; 0) &#123;</span><br><span class="line">              this.init()</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          this.timer += 1</span><br><span class="line">          if (this.timer &gt; 8) &#123;</span><br><span class="line">              this.index = (this.index + 1) % ICON_NUM</span><br><span class="line">              this.timer = 0</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class StarrySky &#123;</span><br><span class="line">      constructor (props) &#123;</span><br><span class="line">          let dom = props.dom</span><br><span class="line">          let t = this</span><br><span class="line">          t.dom = dom</span><br><span class="line">          t.context = dom.getContext(&apos;2d&apos;)</span><br><span class="line">          t.star = new Image()</span><br><span class="line">          t.now = Date.now()</span><br><span class="line"></span><br><span class="line">          let stars = []</span><br><span class="line">          t.stars = stars</span><br><span class="line"></span><br><span class="line">          let loop = t.loop</span><br><span class="line">          t.star.onload = function () &#123;</span><br><span class="line">              t.rect = dom.getBoundingClientRect()</span><br><span class="line">              t.dom.width = t.rect.width</span><br><span class="line">              t.dom.height = t.rect.height</span><br><span class="line"></span><br><span class="line">              for (let i = 0; i &lt; star_num; i++) &#123;</span><br><span class="line">                  stars[i] = new Start(t.star, t.rect)</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              setInterval(loop, 40)</span><br><span class="line"></span><br><span class="line">              window.addEventListener(&apos;resize&apos;, function () &#123;</span><br><span class="line">                  t.rect = dom.getBoundingClientRect()</span><br><span class="line">                  t.dom.width = t.rect.width</span><br><span class="line">                  t.dom.height = t.rect.height</span><br><span class="line">                  stars.map(s =&gt; &#123;</span><br><span class="line">                      s.init(t.rect)</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          this.star.src = star_png</span><br><span class="line">      &#125;</span><br><span class="line">      loop = () =&gt; &#123;</span><br><span class="line">          this.context.fillStyle = &apos;rgb(10, 15, 39)&apos;</span><br><span class="line">          let &#123;width, height&#125; = this.rect</span><br><span class="line">          this.context.fillRect(0, 0, width, height)</span><br><span class="line">          for (let i = 0; i &lt; star_num; i++) &#123;</span><br><span class="line">              this.stars[i].update()</span><br><span class="line">              this.stars[i].draw(this.context)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> 	const canvas = document.createElement(&apos;canvas&apos;)</span><br><span class="line">  canvas.width = document.documentElement.clientWidth</span><br><span class="line">  canvas.height = document.documentElement.clientHeight</span><br><span class="line">  document.body.insertBefore(canvas, document.body.children[0])</span><br><span class="line">  canvas.className = &apos;starry-sky&apos;</span><br><span class="line">  let starrySky = new StarrySky(&#123;</span><br><span class="line">      dom: canvas</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>]]></content>
      
        
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 接入微信支付宝支付]]></title>
      <url>/2018/03/11/Android%20%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/</url>
      <content type="html"><![CDATA[<ul>
<li>按照惯例，首先通读一遍官网文档。<a id="more"></a>
<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2></li>
</ul>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h3 id="微信开放平台"><a href="#微信开放平台" class="headerlink" title="微信开放平台"></a>微信开放平台</h3><ul>
<li>注册账号，创建应用，开通微信支付，这些大家都会的。</li>
</ul>
<h3 id="微信商户平台"><a href="#微信商户平台" class="headerlink" title="微信商户平台"></a>微信商户平台</h3><p>APP支付文档<br><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_1</a> ，<br>如果仅按照文档来，保证每次支付结果都是-1，对，只有-1，<br>没有任何其他信息，不得不说，坑比。</p>
<p>APP支付时序图<br>大概了解下支付流程：<br><img src="http://appzy.vip/images/apply.png" alt="支付流程"></p>
<h2 id="接入SDK"><a href="#接入SDK" class="headerlink" title="接入SDK"></a>接入SDK</h2><h3 id="引入libs"><a href="#引入libs" class="headerlink" title="引入libs"></a>引入libs</h3><p>SDK下载：<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1</a> ，<br>将libammsdk.jar放到libs文件夹下</p>
<h3 id="配置debug签名"><a href="#配置debug签名" class="headerlink" title="配置debug签名"></a>配置debug签名</h3><p>创建应用需要填写应用签名，配置在debug下直接用的正式的key，这样就不用每次打包才能调起微信客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            storeFile file(&quot;你的keystore路径&quot;)</span><br><span class="line">            storePassword &quot;xxx&quot;</span><br><span class="line">            keyAlias &quot;xxx&quot;</span><br><span class="line">            keyPassword &quot;xxx&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(&quot;你的keystore路径&quot;)</span><br><span class="line">            storePassword &quot;xxx&quot;</span><br><span class="line">            keyAlias &quot;xxx&quot;</span><br><span class="line">            keyPassword &quot;xxx&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WXPayEntryActivity"><a href="#WXPayEntryActivity" class="headerlink" title="WXPayEntryActivity"></a>WXPayEntryActivity</h3><p>这个文档没有半点介绍，WXPayEntryActivity是支付结束的回调，<br>和微信分享WXEntryActivity类似，必须放在包名.wxapi下，页面可以自己写。</p>
<p>AndroidManifest.xml中注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 微信支付 --&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">    android:exported=&quot;true&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>网络权限注册不用说了。</p>
<h3 id="支付接口调用"><a href="#支付接口调用" class="headerlink" title="支付接口调用"></a>支付接口调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信支付</span><br><span class="line"> * @param data接口返回</span><br><span class="line"> */</span><br><span class="line">private void weixinPay(String data) &#123;</span><br><span class="line">    // 通过WXAPIFactory工厂，获取IWXAPI的实例</span><br><span class="line">    IWXAPI api = WXAPIFactory.createWXAPI(this, WEIXIN_APP_ID);</span><br><span class="line">    // 将该app注册到微信</span><br><span class="line">    api.registerApp(WEIXIN_APP_ID);</span><br><span class="line">    LogUtil.d(&quot;data=&quot; + data);</span><br><span class="line">    try &#123;</span><br><span class="line">        JSONObject json = new JSONObject(data);</span><br><span class="line">        PayReq req = new PayReq();</span><br><span class="line">        req.appId = json.getString(&quot;appid&quot;);</span><br><span class="line">        req.partnerId = json.getString(&quot;partnerid&quot;);</span><br><span class="line">        req.prepayId = json.getString(&quot;prepayid&quot;);</span><br><span class="line">        req.nonceStr = json.getString(&quot;noncestr&quot;);</span><br><span class="line">        req.timeStamp = json.getString(&quot;timestamp&quot;);</span><br><span class="line">        req.packageValue = json.getString(&quot;package&quot;);</span><br><span class="line">        req.sign = json.getString(&quot;sign&quot;);</span><br><span class="line">        req.extData = &quot;app data&quot;; // optional</span><br><span class="line">        // 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信</span><br><span class="line">        api.sendReq(req);</span><br><span class="line">    &#125; catch (JSONException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了安全，APP端调起支付的参数需要商户后台系统提供接口返回，<br>参数说明文档：<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&amp;index=2" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&amp;index=2</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>以为这样就可以调起微信客户端支付了，没有想到一直返回支付结果为-1，<br>没有多余的信息提示，不亏是微信，Android代码就是简洁！<br>我们看到文档返回-1的提示“可能的原因：签名错误、未注册APPID、<br>项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等。”，<br>我反复检查签名、APPID均没有错误，后台也确定sign信息正确，<br>哎，我表示很无奈，iOS也调用了，他们提示”支付场景非法“，<br>原来是由于后台之前做web支付，trade_type没有改成APP，<br>改了我这边就能正常调起了。</p>
<p><img src="http://appzy.vip/images/pay.jpg" alt="image"></p>
<h2 id="支付宝接入"><a href="#支付宝接入" class="headerlink" title="支付宝接入"></a>支付宝接入</h2><h3 id="前期准备-1"><a href="#前期准备-1" class="headerlink" title="前期准备"></a>前期准备</h3><p>注册账号，创建应用，开通支付功能，这些也不说了。</p>
<h3 id="接入文档"><a href="#接入文档" class="headerlink" title="接入文档"></a>接入文档</h3><p><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7386797.0.0.Eky59h&amp;treeId=59&amp;articleId=103563&amp;docType=1" target="_blank" rel="noopener">https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7386797.0.0.Eky59h&amp;treeId=59&amp;articleId=103563&amp;docType=1</a></p>
<h3 id="支付交互流程"><a href="#支付交互流程" class="headerlink" title="支付交互流程"></a>支付交互流程</h3><p><img src="http://appzy.vip/images/jh.png" alt="交互流程"></p>
<h3 id="接入SDK-1"><a href="#接入SDK-1" class="headerlink" title="接入SDK"></a>接入SDK</h3><p>SDK下载：<br><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Q5gnm8&amp;treeId=193&amp;articleId=104509&amp;docType=1" target="_blank" rel="noopener">https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Q5gnm8&amp;treeId=193&amp;articleId=104509&amp;docType=1</a> ，<br>将alipaySdk-xxxxxxxx.jar包放到libs文件夹下</p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>添加权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>添加声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 支付宝 alipay sdk begin --&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden|navigation&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:screenOrientation=&quot;behind&quot;&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.alipay.sdk.auth.AuthActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden|navigation&quot;</span><br><span class="line">    android:exported=&quot;false&quot;</span><br><span class="line">    android:screenOrientation=&quot;behind&quot;&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<h3 id="支付接口调用-1"><a href="#支付接口调用-1" class="headerlink" title="支付接口调用"></a>支付接口调用</h3><p>支付行为需要在独立的非ui线程中执行，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case SDK_PAY_FLAG: &#123;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj);</span><br><span class="line">                    /**</span><br><span class="line">                     对于支付结果，请商户依赖服务端的异步通知结果。同步通知结果，仅作为支付结束的通知。</span><br><span class="line">                     */</span><br><span class="line">                    String resultInfo = payResult.getResult();// 同步返回需要验证的信息</span><br><span class="line">                    String resultStatus = payResult.getResultStatus();</span><br><span class="line">                    // 判断resultStatus 为9000则代表支付成功</span><br><span class="line">                    if (TextUtils.equals(resultStatus, &quot;9000&quot;)) &#123;</span><br><span class="line">                        // 该笔订单是否真实支付成功，需要依赖服务端的异步通知。</span><br><span class="line">                        Toast.makeText(mActivity, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 该笔订单真实的支付结果，需要依赖服务端的异步通知。</span><br><span class="line">                        Toast.makeText(mActivity, payResult.getMemo(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">     * 支付宝</span><br><span class="line">     */</span><br><span class="line">    private void alipay(final String orderInfo) &#123;</span><br><span class="line">        Runnable payRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                PayTask alipay = new PayTask(mActivity);</span><br><span class="line">                Map&lt;String, String&gt; result = alipay.payV2(orderInfo, true);</span><br><span class="line">                Log.i(&quot;msp&quot;, result.toString());</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = SDK_PAY_FLAG;</span><br><span class="line">                msg.obj = result;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread payThread = new Thread(payRunnable);</span><br><span class="line">        payThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同样为了安全，这里orderInfo是后台接口返回，参数说明文档：<br><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.DwA283&amp;treeId=59&amp;articleId=103663&amp;docType=1" target="_blank" rel="noopener">https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.DwA283&amp;treeId=59&amp;articleId=103663&amp;docType=1</a></p>
<p>这样就over了，相比于微信支付，简单的不能再简单。</p>
<h3 id="orderString内容"><a href="#orderString内容" class="headerlink" title="orderString内容"></a>orderString内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app_id=&amp;</span><br><span class="line">timestamp=&amp;</span><br><span class="line">biz_content=&amp;</span><br><span class="line">method=alipay.trade.app.pay&amp;</span><br><span class="line">charset=utf-8&amp;</span><br><span class="line">version=1.0&amp;</span><br><span class="line">sign_type=RSA2&amp;</span><br><span class="line">sign=</span><br></pre></td></tr></table></figure>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>1、系统繁忙，请稍后再试(ALI40247)<br>检查下 服务端使用 alipay.trade.app.pay 接口的私钥是不是和 APPID 应用下的公钥匹配，<br>进行「秘钥匹配」工具：<a href="https://doc.open.alipay.com/docs/doc.htm?treeId=291&amp;articleId=106097&amp;docType=1" target="_blank" rel="noopener">https://doc.open.alipay.com/docs/doc.htm?treeId=291&amp;articleId=106097&amp;docType=1</a></p>]]></content>
      
        
        <tags>
            
            <tag> AndroidPay </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DeviceInfo采集android设备信息工具]]></title>
      <url>/2018/02/02/DeviceInfo%E9%87%87%E9%9B%86android%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<ul>
<li>采集Android设备信息，以Json形式输出</li>
<li>可自由定制要采集的设备类型，显示的设备信息详情等<a id="more"></a>
<h2 id="库介绍"><a href="#库介绍" class="headerlink" title="库介绍"></a>库介绍</h2></li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>采集Android设备信息，以Json形式输出</p>
<p>可自由定制要采集的设备类型，显示的设备信息详情等</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>通过继承<code>BaseDeviceInfoCollector</code>类，配合<code>DeviceInfoManager</code>以获取任意设备信息</li>
<li>通过<code>DeviceInfoManager</code>管理每个设备信息采集器（下简称：Collector），可自由添加Collector，以同时采集N多种软硬件设备信息</li>
<li>Collector分为自动采集和手动采集两种采集方式。<ul>
<li>自动采集：Manager控制自发进行的采集</li>
<li>手动采集：需要用户参与交互的数据采集过程</li>
</ul>
</li>
<li>Manager管理的多个Collector做并发自动采集，手动采集可以配置在自动采集动作结束后自行开始</li>
<li>每个Collector独立管理各自所需要的权限，在Manager中统一申请（SDK_VERSION &gt;= 23）</li>
<li>可选择获取所有的模块的设备信息（Json），也可以选择只输出单一模块（Json）</li>
<li>提供丰富的状态回调接口<code>DeviceInfoCollectListener</code>，可以监听采集结束等各种状态</li>
</ul>
<h2 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h2><ul>
<li>默认输出：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;board&quot;: &#123;&quot;boardName&quot;: &quot;MSM8939&quot;&#125;,</span><br><span class="line">    &quot;sim&quot;: [&#123;</span><br><span class="line">        &quot;dataState&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;imsi&quot;: &quot;460036820263837&quot;,</span><br><span class="line">        &quot;isNetworkRoaming&quot;: &quot;false&quot;,</span><br><span class="line">        &quot;networkOperatorName&quot;: &quot;China Telecom&quot;,</span><br><span class="line">        &quot;networkType&quot;: &quot;14&quot;,</span><br><span class="line">        &quot;phoneType&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;simCountryIso&quot;: &quot;cn&quot;,</span><br><span class="line">        &quot;simOperator&quot;: &quot;46003&quot;,</span><br><span class="line">        &quot;simSerialNumber&quot;: &quot;89860315844110607274&quot;,</span><br><span class="line">        &quot;simState&quot;: &quot;0&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>自定义设备信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DeviceInfoManager.NewInstance(this)</span><br><span class="line">        .addCollector(new PhoneBasicInfoCollector(this, &quot;basic&quot;))       //Andorid设备基本信息（PhoneBasicInfoCollector）</span><br><span class="line">        .addCollector(new SimInfoCollector(this, &quot;sim&quot;))                //Sim卡信息（SimInfoCollector）同时识别多张Sim卡</span><br><span class="line">        .addCollector(new CpuInfoCollector(this, &quot;cpu&quot;))                //Cpu信息（CpuInfoCollector）</span><br><span class="line">        .addCollector(new BoardInfoCollector(this, &quot;board&quot;))            //主板信息（BoardInfoCollector）</span><br><span class="line">        .addCollector(new BatteryInfoCollector(this, &quot;battery&quot;))        //电池信息（BatteryInfoCollector）</span><br><span class="line">        .addCollector(new StorageInfoCollector(this, &quot;storage&quot;))        //存储信息（RAM &amp; SD）（StorageInfoCollector）</span><br><span class="line">        .addCollector(new CameraInfoCollector(this, &quot;camera&quot;, true))    //摄像头信息（CameraInfoCollector）</span><br><span class="line">        .addCollector(new ScreenInfoCollector(this, &quot;screen&quot;))          //屏幕信息（ScreenInfoCollector）</span><br><span class="line">        .addCollector(new UiInfoCollector(this, &quot;ui&quot;))                  //Ui信息（UiInfoCollector）</span><br><span class="line">        .addCollector(new SensorInfoCollector(this, &quot;sensor&quot;))          //传感器列表（SensorInfoCollector）</span><br><span class="line">        .addCollector(new NfcInfoCollector(this, &quot;nfc&quot;))                //NFC信息（NfcInfoCollector）</span><br><span class="line">        .addCollector(new SystemInfoCollector(this, &quot;system&quot;))          //系统相关信息（Build.prop等）</span><br><span class="line">        .autoStartManualCollection(true)</span><br><span class="line">        .bindListener(mDeviceInfoCollectListener)</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然也可以通过重写每个Collector的<code>public String getJsonInfo();</code>以自定义Json的输出内容</p>
</li>
</ul>
<h2 id="目前可获取的设备信息（只作为模板用途，建议使用时自行定制）"><a href="#目前可获取的设备信息（只作为模板用途，建议使用时自行定制）" class="headerlink" title="目前可获取的设备信息（只作为模板用途，建议使用时自行定制）"></a>目前可获取的设备信息（只作为模板用途，建议使用时自行定制）</h2><ul>
<li>Andorid设备基本信息（PhoneBasicInfoCollector）</li>
<li>Sim卡信息（SimInfoCollector）<ul>
<li>同时识别多张Sim卡    </li>
</ul>
</li>
<li>主板信息（BoardInfoCollector）</li>
<li>Cpu信息（CpuInfoCollector）</li>
<li>电池信息（BatteryInfoCollector）</li>
<li>屏幕信息（ScreenInfoCollector）</li>
<li>NFC信息（NfcInfoCollector）</li>
<li>传感器列表（SensorInfoCollector）</li>
<li>摄像头信息（CameraInfoCollector）</li>
<li>存储信息（RAM &amp; SD）（StorageInfoCollector）</li>
<li>Ui信息（UiInfoCollector）</li>
<li>系统相关信息（Build.prop等）</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h3><p><a href="https://jitpack.io/#appzy/DeviceInfo" target="_blank" rel="noopener"><img src="https://jitpack.io/v/appzy/DeviceInfo.svg" alt=""></a><br><a href="https://github.com/appzy/DeviceInfo/issues" target="_blank" rel="noopener"><img src="https://img.shields.io/github/issues/appzy/DeviceInfo.svg" alt="GitHub issues"></a></p>
<blockquote>
<p>库版本号 <em>version</em> 请看上方 <strong>JitPack</strong> 的最新版本号，如<code>v1.0.2</code>，并不是 ~<em>xxx</em>~ （推荐使用最新版）</p>
</blockquote>
<h4 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h4><ul>
<li><p>Step 1.Add it in your root build.gradle at the end of repositories</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		...</span><br><span class="line">		maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Step 2.Add the dependency</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       	compile &apos;com.github.guyuepeng:DeviceInfo:xxx&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><ul>
<li><p>Step 1.Add it in your root build.gradle at the end of repositories</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">	&lt;repository&gt;</span><br><span class="line">	    &lt;id&gt;jitpack.io&lt;/id&gt;</span><br><span class="line">	    &lt;url&gt;https://jitpack.io&lt;/url&gt;</span><br><span class="line">	&lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Step 2.Add the dependency</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.guyuepeng&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;DeviceInfo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;xxx&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="拓展自定义Collector"><a href="#拓展自定义Collector" class="headerlink" title="拓展自定义Collector"></a>拓展自定义Collector</h4><p>通过继承<code>BaseDeviceInfoCollector</code>抽象类进行功能拓展，以采集更多信息，或输出自定义的Json内容</p>
<ul>
<li><code>public DemoCollector(Context context, String collectorName)</code>中的<code>collectorName</code></li>
<li><code>public abstract boolean needCollectManually();</code>返回自定义Collector是否需要手动收集</li>
<li><code>public abstract String[] getRequiredPermissions();</code>返回自定义Collector所需要的权限（每个Collector独立管理权限，Manager统一申请）</li>
<li><code>protected abstract void doCollectAutomatically();</code>Collector做自动采集的方法</li>
<li><code>protected abstract void doCollectManually();</code>Collector做手动采集的方法，若采用Manager统一管理，需要<code>needCollectManually()</code>的返回值为<code>true</code>此方法才会被调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package ltns.deviceinfolib.collector;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @date 创建时间：2018/1/8</span><br><span class="line"> * @author appzy</span><br><span class="line"> * @Description</span><br><span class="line"> * @version</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DemoCollector extends BaseDeviceInfoCollector &#123;</span><br><span class="line">    public DemoCollector(Context context, String collectorName) &#123;</span><br><span class="line">        super(context, collectorName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean needCollectManually() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String[] getRequiredPermissions() &#123;</span><br><span class="line">        return new String[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doCollectAutomatically() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doCollectManually() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过Manager管理多个Collector"><a href="#通过Manager管理多个Collector" class="headerlink" title="通过Manager管理多个Collector"></a>通过Manager管理多个Collector</h4><p>为了代码简洁易读，我把它设计成这样：（不知道这样写会不会违背什么设计模式，如果有请issues告诉我，谢谢:D）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DeviceInfoManager.NewInstance(this)</span><br><span class="line">                .addCollector(new BoardInfoCollector(MainActivity.this, &quot;board&quot;))</span><br><span class="line">                .addCollector(new SimInfoCollector(MainActivity.this, &quot;sim&quot;))</span><br><span class="line">                .autoStartManualCollection(true)</span><br><span class="line">                .bindListener(mDeviceInfoCollectListener)</span><br><span class="line">                .start();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>addCollector(BaseDeviceInfoCollector)</code>添加一个新的Collector到Manager中</li>
<li><code>autoStartManualCollection(boolean)</code>默认是true，自动采集全部完成后立即开启手动采集队列</li>
</ul>
<p>在DeviceInfoCollectListener中监听采集状态：</p>
<ul>
<li><code>mDeviceInfoManager.getDeviceJsonInfo();</code>方法获取到Manager中所有Collector采集到的信息</li>
<li><code>mCollector.getJsonInfo();</code>方法获取单个Collector中的信息</li>
<li><code>void onStart();</code>Manager调用start()时回调</li>
<li><code>void onSingleSuccess(BaseDeviceInfoCollector mCollector);</code>当有某个Collector成功采集到信息后回调</li>
<li><code>void onSingleFailure(BaseDeviceInfoCollector mCollector, String mErrorInfo);</code>当有某个Collector采集信息失败后回调（并不一定没有采集到数据，已经采集到的信息仍会被以Json格式输出）</li>
<li><code>void onAllDone(DeviceInfoManager mDeviceInfoManager);</code>通过addCollector(…)方法添加到Manager中的所有Collector均完成采集动作后回调，需要说明的是，不一定是全部采集成功了，只是采集动作完成了</li>
<li><code>void onAutoAllDone(DeviceInfoManager mDeviceInfoManager);</code>当抛开需要手动收集的收集器，其他的收集器全部完成采集动作后回调</li>
</ul>
<blockquote>
<p>注意：<code>onSingleFailure(BaseDeviceInfoCollector mCollector, String mErrorInfo)</code>中也可能存在数据，即<code>mCollector.getJsonInfo();</code>也可能会有数据，具体原因可参考源码和下方 <strong>注意事项</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private DeviceInfoCollectListener mDeviceInfoCollectListener = new DeviceInfoCollectListener() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void onStart() &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onSingleSuccess(BaseDeviceInfoCollector mCollector) &#123;</span><br><span class="line">       	//mCollector.getJsonInfo();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onSingleFailure(BaseDeviceInfoCollector mCollector, String mErrorInfo) &#123;</span><br><span class="line">       	//mCollector.getJsonInfo();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAllDone(DeviceInfoManager mDeviceInfoManager) &#123;</span><br><span class="line">       	// mDeviceInfoManager.getDeviceJsonInfo();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAutoAllDone(DeviceInfoManager mDeviceInfoManager) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Collector单独跑也是支持的"><a href="#Collector单独跑也是支持的" class="headerlink" title="Collector单独跑也是支持的"></a>Collector单独跑也是支持的</h4><p><em>（支持但不推荐）</em></p>
<p>当然还是推荐使用Manager :D。就是想要自己单独跑也可以，接着~</p>
<blockquote>
<p>特别说明：Collector单独跑需要调用者自行申请权限，因此方便起见，推荐使用Manager统一管理</p>
</blockquote>
<p>以<code>BoardInfoCollector</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BoardInfoCollector mCollector = new BoardInfoCollector(MainActivity.this, &quot;board&quot;);</span><br><span class="line">        mCollector.bindObserver(mStateObserver);</span><br><span class="line">        mCollector.startCollectAutomatically();//启动自动采集</span><br><span class="line">        mCollector.startCollectManually();//启动手动采集</span><br></pre></td></tr></table></figure>
<p>在<code>CollectorStateObserver</code>中监听Collector状态：</p>
<ul>
<li><code>void onCollectionSuccess(BaseDeviceInfoCollector mCollector);</code>当手动采集和自动收集均成功完成采集时调用</li>
<li><code>void onCollectionFailure(BaseDeviceInfoCollector mCollector,String mErrorInfo);</code></li>
<li><code>void onManualCollectionSuccess(BaseDeviceInfoCollector mCollector,boolean startNext);</code> 当手动参与的信息收集成功时调用。 <strong>P.s.</strong> 此方法回调时会同时回调onCollectionSuccess()，具体看源码</li>
<li><code>void onManualCollectionFailure(BaseDeviceInfoCollector mCollector,String mErrorInfo,boolean startNext);</code> 当手动参与的信息收集失败时调用。 <strong>P.s.</strong> 此方法回调时会同时回调onCollectionFailure(…)</li>
<li><code>void onNeedManualCollect(BaseDeviceInfoCollector mCollector);</code>该采集器需要手动采集时回调，具体回调时间请看源码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private CollectorStateObserver mStateObserver=new CollectorStateObserver() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCollectionSuccess(BaseDeviceInfoCollector mCollector) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCollectionFailure(BaseDeviceInfoCollector mCollector, String mErrorInfo) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onManualCollectionSuccess(BaseDeviceInfoCollector mCollector, boolean startNext) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onManualCollectionFailure(BaseDeviceInfoCollector mCollector, String mErrorInfo, boolean startNext) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNeedManualCollect(BaseDeviceInfoCollector mCollector) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>多个Collector的自动采集过程是并发的，运行在子线程中；手动采集方法运行在主线程中</li>
<li>Manager的监听回调不一定在主线程，因此若操作涉及线程安全，如更新UI，建议使用<code>Handler</code></li>
<li>Manager的<code>boolean isManualCollectionStartAutomatically</code>默认为true，若要更改需要手动配置<code>autoStartManualCollection(boolean)</code>为false。若设置为false，需要调用<code>startCollectByHand</code>开启手动采集队列；当然也可以单独开启某个Collector的手动采集</li>
<li><code>onSingleFailure(BaseDeviceInfoCollector mCollector, String mErrorInfo)</code>回调中通过调用<code>mCollector.getJsonInfo();</code>方法仍可以获取到<code>doCollectAutomatically();</code>方法中采集到的自动收集部分的设备信息</li>
<li>库内内置了<a href="https://github.com/yanzhenjie/AndPermission" target="_blank" rel="noopener">AndPermission</a>库以处理权限相关，<a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>以处理Json相关</li>
<li>库内所有的Collector实现类只做模板使用，建议使用时自行继承<code>BaseDeviceInfoCollector</code>实现；若要使用库内Collector，需要在 <em>Manifests.xml</em> 中声明对应权限后才能正常使用</li>
</ul>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li>上传库，提供Sim&amp;Board信息采集支持，更新README（2017.06.23）</li>
<li>添加CPU、设备基本信息采集支持，更新Sim注释，发布v1.0.1（2017.06.23）</li>
<li>添加更多信息采集模板类（Battery,NFC,Camera…），统一输出（Json）中key的命名规范（2017.06.26）</li>
<li>添加了系统描述相关信息的采集，修改了Demo.apk中的Json的显示方式（2017.06.29）</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li>库内使用了 <strong>严振杰</strong> 的<a href="https://github.com/yanzhenjie/AndPermission" target="_blank" rel="noopener">AndPermission</a>库</li>
</ul>
<h2 id="扯扯淡"><a href="#扯扯淡" class="headerlink" title="扯扯淡"></a>扯扯淡</h2><ul>
<li>源码地址：<a href="https://github.com/appzy/DeviceInfo" target="_blank" rel="noopener">https://github.com/appzy/DeviceInfo</a></li>
<li>如果觉得有用，欢迎Stars</li>
</ul>]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 设备信息 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 内存优化]]></title>
      <url>/2017/11/25/Android%20%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="为什么优化"><a href="#为什么优化" class="headerlink" title="为什么优化"></a>为什么优化</h2><p>虽然 Java 对内存的释放有垃圾自动回收机制，但是实际开发中，<br>不再用到的对象因为被错误引用会导致无法回收，从而造成内存泄漏，<br>甚至内存溢出 OOM（OutOfMemory），程序崩溃。</p>
<a id="more"></a>
<h3 id="Android-GC-原理"><a href="#Android-GC-原理" class="headerlink" title="Android GC 原理"></a>Android GC 原理</h3><p>参考：<a href="https://mp.weixin.qq.com/s/CUU3Ml394H_fkabhNNX32Q" target="_blank" rel="noopener">Android GC 原理探究</a></p>
<h3 id="Android-内存管理"><a href="#Android-内存管理" class="headerlink" title="Android 内存管理"></a>Android 内存管理</h3><p>参考：<a href="https://developer.android.google.cn/topic/performance/memory-overview" target="_blank" rel="noopener">Android 内存管理</a></p>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><h3 id="使用-LeakCanary"><a href="#使用-LeakCanary" class="headerlink" title="使用 LeakCanary"></a>使用 LeakCanary</h3><p>Android 内存泄漏检测库：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a> ，善于使用 LeakCanary 发现内存泄漏。</p>
<h3 id="Memory-Monitor工具"><a href="#Memory-Monitor工具" class="headerlink" title="Memory Monitor工具"></a>Memory Monitor工具</h3><p>Android Studio 中的 Android Monitor ，选择其中的 Memory，跟踪整个 APP 的内存变化情况。<br>步骤如下：<br>1、与您的应用交互，在 Memory 监视器中，查看 Free 和 Alloated 内存。<br>2、点击 Dump Java Heap：<br><img src="http://7q5c2h.com1.z0.glb.clouddn.com/monitor-heap-dump.png" alt=""><br>，这个会打开 HPROF 查看器，如果没有，在 Captures 标签中，双击堆快照文件以打开 HPROF 查看器。<br>3、要引起堆分配，请与您的应用交互，然后点击触发 GC 的按钮：<br><img src="http://7q5c2h.com1.z0.glb.clouddn.com/monitor-garbage-collect.png" alt=""></p>
<h3 id="Heap-Viewer-工具"><a href="#Heap-Viewer-工具" class="headerlink" title="Heap Viewer 工具"></a>Heap Viewer 工具</h3><p>实时查看App分配的内存大小和空闲内存大小，发现 Memory Leaks 。<br>详细使用教程：<a href="https://www.kancloud.cn/digest/itfootballprefermanc/100907" target="_blank" rel="noopener">Heap Viewer工具</a></p>
<h3 id="Allocation-Tracker"><a href="#Allocation-Tracker" class="headerlink" title="Allocation Tracker"></a>Allocation Tracker</h3><p>追踪内存对象的来源。<br>详细使用教程：<a href="https://www.kancloud.cn/digest/itfootballprefermanc/100908" target="_blank" rel="noopener">Allocation Tracker(Device Monitor)</a></p>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="检查使用多少内存"><a href="#检查使用多少内存" class="headerlink" title="检查使用多少内存"></a>检查使用多少内存</h3><p>每个 APP 的堆（heap）内存大小有硬性限制，如果您的 APP 已达到堆内存限制，并尝试分配更多的内存，<br>系统会抛出 OutOfMemoryError 。为了避免 OOM ，您可以查询当前设备有多少堆空间，<br>可以通过调用系统 getMemoryInfo() 查询，返回 一个ActivityManager.MemoryInfo 对象，<br>它提供该设备当前存储器的状态信息，包括可用的存储器，总存储器，和低于该阈值存储器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void getMemoryInfo() &#123;</span><br><span class="line">    ActivityManager activityManager = (ActivityManager) this.getSystemService(ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();</span><br><span class="line">    activityManager.getMemoryInfo(memoryInfo);</span><br><span class="line">    LogUtil.d(&quot;totalMem=&quot; + memoryInfo.totalMem + &quot;,availMem=&quot; + memoryInfo.availMem);</span><br><span class="line">    if (!memoryInfo.lowMemory) &#123;</span><br><span class="line">        // 运行在低内存环境</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="当界面不可见时释放内存"><a href="#当界面不可见时释放内存" class="headerlink" title="当界面不可见时释放内存"></a>当界面不可见时释放内存</h3><p>实现 <a href="https://developer.android.google.cn/reference/android/content/ComponentCallbacks2.html" target="_blank" rel="noopener">ComponentCallbacks2</a> API 中 <a href="https://developer.android.google.cn/reference/android/content/ComponentCallbacks2#onTrimMemory(int" target="_blank" rel="noopener">onTrimMemory()</a>)，<br>当回调参数 level 为 TRIM_MEMORY_UI_HIDDEN ，是用户点击了Home键或者Back键退出应用，<br>所有UI界面被隐藏，这时候应该释放一些不可见的时候非必须的资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity</span><br><span class="line">    implements ComponentCallbacks2 &#123;</span><br><span class="line">    // Other activity code ...</span><br><span class="line">    /**</span><br><span class="line">     * Release memory when the UI becomes hidden or when system resources become low.</span><br><span class="line">     * @param level the memory-related event that was raised.</span><br><span class="line">     */</span><br><span class="line">    public void onTrimMemory(int level) &#123;</span><br><span class="line">        // Determine which lifecycle or system event was raised.</span><br><span class="line">        switch (level) &#123;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line">                /*</span><br><span class="line">                   Release any UI objects that currently hold memory.</span><br><span class="line">                   The user interface has moved to the background.</span><br><span class="line">                */</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line">                /*</span><br><span class="line">                   Release any memory that your app doesn&apos;t need to run.</span><br><span class="line">                   The device is running low on memory while the app is running.</span><br><span class="line">                   The event raised indicates the severity of the memory-related event.</span><br><span class="line">                   If the event is TRIM_MEMORY_RUNNING_CRITICAL, then the system will</span><br><span class="line">                   begin killing background processes.</span><br><span class="line">                */</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line">                /*</span><br><span class="line">                   Release as much memory as the process can.</span><br><span class="line">                   The app is on the LRU list and the system is running low on memory.</span><br><span class="line">                   The event raised indicates where the app sits within the LRU list.</span><br><span class="line">                   If the event is TRIM_MEMORY_COMPLETE, the process will be one of</span><br><span class="line">                   the first to be terminated.</span><br><span class="line">                */</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                /*</span><br><span class="line">                  Release any non-critical data structures.</span><br><span class="line">                  The app received an unrecognized memory level value</span><br><span class="line">                  from the system. Treat this as a generic low-memory message.</span><br><span class="line">                */</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该 onTrimMemory() 回调是在搭载Android 4.0（API级别14）加入。对于早期版本，您可以使用 onLowMemory() 回调作为旧版本的回调，这大致相当于 TRIM_MEMORY_COMPLETE事件。</p>
<h3 id="谨慎使用服务"><a href="#谨慎使用服务" class="headerlink" title="谨慎使用服务"></a>谨慎使用服务</h3><p>离开了 APP 还在运行服务是最糟糕的内存管理错误之一，当 APP 处在后台，我们应该停止服务，<br>除非它需要运行的任务。我们可以使用 <a href="https://developer.android.google.cn/topic/performance/background-optimization" target="_blank" rel="noopener">JobScheduler</a> 替代实现，<br><a href="https://developer.android.google.cn/topic/performance/background-optimization" target="_blank" rel="noopener">JobScheduler</a> 把一些不是特别紧急的任务放到更合适的时机批量处理。如果必须使用一个服务，<br>最佳方法是使用 <a href="https://developer.android.google.cn/training/run-background-service/index.html" target="_blank" rel="noopener">IntentService</a> ，限制服务寿命，所有请求处理完成后，IntentService 会自动停止。</p>
<h3 id="使用优化的数据容器"><a href="#使用优化的数据容器" class="headerlink" title="使用优化的数据容器"></a>使用优化的数据容器</h3><p>考虑使用优化过数据的容器 SparseArray / SparseBooleanArray / LongSparseArray 代替 HashMap 等传统数据结构，通用 HashMap 的实现可以说是相当低效的内存，因为它需要为每个映射一个单独的条目对象。</p>
<h3 id="避免在-Android-上使用枚举"><a href="#避免在-Android-上使用枚举" class="headerlink" title="避免在 Android 上使用枚举"></a>避免在 Android 上使用枚举</h3><p>枚举往往需要两倍多的内存，静态常量更多，我们应该严格避免在 Android 上使用枚举。</p>
<h3 id="使用-nano-protobufs-序列化数据"><a href="#使用-nano-protobufs-序列化数据" class="headerlink" title="使用 nano protobufs 序列化数据"></a>使用 nano protobufs 序列化数据</h3><p>Protocol buffers 是一个语言中立，平台中立的，可扩展的机制，由谷歌进行序列化结构化数据，类似于 XML 设计的，但是更小，更快，更简单。如果需要为您的数据序列化与协议化，建议使用 nano protobufs。</p>
<h3 id="避免内存流失"><a href="#避免内存流失" class="headerlink" title="避免内存流失"></a>避免内存流失</h3><p>内存流失可能会导致出现大量的 GC 事件，如自定义组件的 onDraw() ，避免大量创建临时对象，比如 String ，以免频繁触发 GC。GC 事件通常不影响您的 APP 的性能，然而在很短的时间段，发生许多垃圾收集事件可以快速地吃了您的帧时间，系统上时间的都花费在 GC ，就有很少时间做其他的东西像渲染或音频流。</p>
<h3 id="使用ProGuard来剔除不需要的代码"><a href="#使用ProGuard来剔除不需要的代码" class="headerlink" title="使用ProGuard来剔除不需要的代码"></a>使用ProGuard来剔除不需要的代码</h3><p>使用 ProGuard 来剔除不需要的代码，移除任何冗余的，不必要的，或臃肿的组件，资源或库完善 APP 的内存消耗。</p>
<h3 id="降低整体尺寸APK"><a href="#降低整体尺寸APK" class="headerlink" title="降低整体尺寸APK"></a>降低整体尺寸APK</h3><p>您可以通过减少 APP 的整体规模显著减少 APP 的内存使用情况。文章：<a href="http://wuxiaolong.me/2017/03/19/ReduceAPKSize/" target="_blank" rel="noopener">Android APK瘦身实践</a></p>
<h3 id="优化布局层次"><a href="#优化布局层次" class="headerlink" title="优化布局层次"></a>优化布局层次</h3><p>通过优化视图层次结构，以减少重叠的 UI 对象的数量来提高性能。文章：<a href="http://wuxiaolong.me/2017/03/26/Rendering/" target="_blank" rel="noopener">Android 渲染优化</a></p>
<h3 id="使用-Dagger-2依赖注入"><a href="#使用-Dagger-2依赖注入" class="headerlink" title="使用 Dagger 2依赖注入"></a>使用 Dagger 2依赖注入</h3><p>依赖注入框架可以简化您写的代码，并提供一个自适应环境测试和便于其他配置的更改。如果打算在您的 APP 使用依赖注入框架，可以考虑用 Dagger 2 ，Dagger 不使用反射扫描 APP 的代码，Dagger 是静态的，意味着它编译时不需要占用运行 Android 应用或内存的使用。</p>
<h3 id="请小心使用外部库"><a href="#请小心使用外部库" class="headerlink" title="请小心使用外部库"></a>请小心使用外部库</h3><p>外部库的代码往往是未针对移动环境下编写并用于工作在移动客户端上时，可能是低效的。当您决定使用外部库，您可能需要优化该库为移动设备。</p>
<h3 id="避免Bitmap浪费"><a href="#避免Bitmap浪费" class="headerlink" title="避免Bitmap浪费"></a>避免Bitmap浪费</h3><p>Bitmap是内存消耗的大头，当使用时要及时回收。另外配置：<br>inSampleSize：缩放比例，图片按需加载，避免不必要的大图载入。<br>decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。</p>
<h3 id="Cursor关闭"><a href="#Cursor关闭" class="headerlink" title="Cursor关闭"></a>Cursor关闭</h3><p>如查询数据库的操作，使用到Cursor，也要对Cursor对象及时关闭。</p>
<h3 id="监听器的注销"><a href="#监听器的注销" class="headerlink" title="监听器的注销"></a>监听器的注销</h3><p>Android程序里面存在很多需要register与unregister的监听器，手动add的listener，需要记得及时remove这个listener。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.google.cn/topic/performance/memory-overview" target="_blank" rel="noopener">官网Overview of Android Memory Management</a></p>
<p><a href="https://developer.android.google.cn/topic/performance/memory" target="_blank" rel="noopener">官网Manage Your App’s Memory</a></p>
<p><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="noopener">Android内存优化之OOM</a></p>]]></content>
      
        
        <tags>
            
            <tag> memory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android代码混淆干货]]></title>
      <url>/2017/09/20/Android%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%B9%B2%E8%B4%A7/</url>
      <content type="html"><![CDATA[<ul>
<li>混淆代码能有效防止被反编译，防止自己的劳动成果被别人窃取;</li>
<li>ProGuard是一个开源的Java代码混淆器。它可以混淆Android项目里面的java代码，对的，你没看错，仅仅是java代码。它是无法混淆Native代码，资源文件drawable、xml等。<a id="more"></a>
</li>
</ul>
<h3 id="ProGuard作用"><a href="#ProGuard作用" class="headerlink" title="ProGuard作用"></a>ProGuard作用</h3><ul>
<li>压缩: 移除无效的类、属性、方法等</li>
<li>优化: 优化字节码，并删除未使用的结构</li>
<li>混淆: 将类名、属性名、方法名混淆为难以读懂的字母，比如a,b,c</li>
</ul>
<h2 id="混淆注意事项"><a href="#混淆注意事项" class="headerlink" title="混淆注意事项"></a>混淆注意事项</h2><h3 id="1-不能被混淆"><a href="#1-不能被混淆" class="headerlink" title="1.不能被混淆"></a>1.不能被混淆</h3><ul>
<li>在AndroidManifest中配置的类，比如四大组件</li>
<li>JNI调用的方法</li>
<li>反射用到的类</li>
<li>WebView中JavaScript调用的方法</li>
<li>Layout文件引用到的自定义View</li>
<li>一些引入的第三方库（一般都会有混淆说明的）</li>
</ul>
<p>这里推荐两个开源项目，里面收集了一些第三方库的混淆规则</p>
<ul>
<li><a href="https://github.com/krschultz/android-proguard-snippets" target="_blank" rel="noopener">https://github.com/krschultz/android-proguard-snippets</a></li>
<li><a href="https://github.com/msdx/android-proguard-cn" target="_blank" rel="noopener">https://github.com/msdx/android-proguard-cn</a></li>
</ul>
<p>混淆之后常遇到的问题，类名会变成a,b,c这种，通过包名+类名自然就会找不到该类了，自然就会出现ClassNotFoundException异常。<br>这里推荐一篇文章：</p>
<ul>
<li><a href="http://www.itnose.net/detail/6043297.html" target="_blank" rel="noopener">http://www.itnose.net/detail/6043297.html</a></li>
</ul>
<h3 id="2-Log处理"><a href="#2-Log处理" class="headerlink" title="2.Log处理"></a>2.Log处理</h3><p>我们都知道，使用Log的时候，需要用到TAG，然而TAG我们一般都会写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String TAG = MainActivity.class.getSimpleName()</span><br></pre></td></tr></table></figure></p>
<p>这时候MainActivity如何被混淆的话，log输出信息就会变成V/a:xxxxxxx，所以为了让log输出信息维持原状，可以将TAG处理成固定的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String TAG = &quot;MainActivity&quot;</span><br></pre></td></tr></table></figure></p>
<p>关于Log处理，推荐一篇文章：<a href="https://www.zybuluo.com/shark0017/note/163330" target="_blank" rel="noopener">https://www.zybuluo.com/shark0017/note/163330</a></p>
<h3 id="3-Crash信息处理"><a href="#3-Crash信息处理" class="headerlink" title="3. Crash信息处理"></a>3. Crash信息处理</h3><p>代码混淆的时候记得加上在混淆文件里面记得加上这句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># keep住源文件以及行号 </span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br></pre></td></tr></table></figure></p>
<p>这里推荐bugly的一篇文章：<a href="http://dev.qq.com/topic/5901b310a1643ba670813363" target="_blank" rel="noopener">http://dev.qq.com/topic/5901b310a1643ba670813363</a></p>
<h2 id="ProGuard使用"><a href="#ProGuard使用" class="headerlink" title="ProGuard使用"></a>ProGuard使用</h2><h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><ul>
<li>-keep {Modifier} {class_specification} 保护指定的类文件和类的成员</li>
<li>-keepclassmembers {modifier} {class_specification} 保护指定类的成员，如果此类受到保护他们会保护的更好</li>
<li>-keepclasseswithmembers {class_specification} 保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。</li>
<li>-keepnames {class_specification} 保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）</li>
<li>-keepclassmembernames {class_specification} 保护指定的类的成员的名称（如果他们不会压缩步骤中删除）</li>
<li>-keepclasseswithmembernames {class_specification} 保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）</li>
<li>-printseeds {filename} 列出类和类的成员-keep选项的清单，标准输出到给定的文件<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3></li>
<li>-dontshrink 不压缩输入的类文件</li>
<li>-printusage {filename}</li>
<li>-whyareyoukeeping {class_specification<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3></li>
<li>-dontoptimize 不优化输入的类文件</li>
<li>-assumenosideeffects {class_specification} 优化时假设指定的方法，没有任何副作用</li>
<li>-allowaccessmodification 优化时允许访问并修改有修饰符的类和类的成员<h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3></li>
<li>-dontobfuscate 不混淆输入的类文件</li>
<li>-obfuscationdictionary {filename} 使用给定文件中的关键字作为要混淆方法的名称</li>
<li>-overloadaggressively 混淆时应用侵入式重载</li>
<li>-useuniqueclassmembernames 确定统一的混淆类的成员名称来增加混淆</li>
<li>-flattenpackagehierarchy {package_name} 重新包装所有重命名的包并放在给定的单一包中</li>
<li>-repackageclass {package_name} 重新包装所有重命名的类文件中放在给定的单一包中</li>
<li>-dontusemixedcaseclassnames 混淆时不会产生形形色色的类名</li>
<li>-keepattributes {attribute_name,…} 保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses.</li>
<li>-renamesourcefileattribute {string} 设置源文件中给定的字符串常量</li>
</ul>
<table>
<thead>
<tr>
<th>通配符</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>？</td>
<td>匹配单个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配类名中的任何部分，但不包含额外的包名</td>
</tr>
<tr>
<td>**</td>
<td>匹配类名中的任何部分，并且可以包含额外的包名</td>
</tr>
<tr>
<td>%</td>
<td>匹配任何基础类型的类型名</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意类型名 ,包含基础类型/非基础类型</td>
</tr>
<tr>
<td>…</td>
<td>匹配任意数量、任意类型的参数</td>
</tr>
<tr>
<td>init&lt;&gt;</td>
<td>匹配任何构造器</td>
</tr>
<tr>
<td>ifield&lt;&gt;</td>
<td>匹配任何字段名</td>
</tr>
<tr>
<td>imethod&lt;&gt;</td>
<td>匹配任何方法</td>
</tr>
<tr>
<td>*(当用在类内部时)</td>
<td>匹配任何字段和方法</td>
</tr>
<tr>
<td>$</td>
<td>指内部类</td>
</tr>
</tbody>
</table>
<h3 id="Android-Studio中使用方法"><a href="#Android-Studio中使用方法" class="headerlink" title="Android Studio中使用方法"></a>Android Studio中使用方法</h3><p>按照上面的语法规则编写proguard-rules.pro后，需要在build.gradle中配置，需要混淆的时候，设置minifyEnabled为true即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        minifyEnabled false //关闭混淆</span><br><span class="line">    &#125;</span><br><span class="line">    release &#123;</span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">        minifyEnabled true //开启混淆</span><br><span class="line">        proguardFiles &apos;proguard-rules.pro&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ProGuard的输出文件说明"><a href="#ProGuard的输出文件说明" class="headerlink" title="ProGuard的输出文件说明"></a>ProGuard的输出文件说明</h3><p>混淆后，会在/build/proguard/目录下输出下面的文件</p>
<ul>
<li>dump.txt 描述apk文件中所有类文件间的内部结构。</li>
<li>mapping.txt 列出了原始的类，方法，和字段名与混淆后代码之间的映射。</li>
<li>seeds.txt 列出了未被混淆的类和成员</li>
<li>usage.txt 列出了从apk中删除的代码 </li>
<li>当我们需要处理crash log的时候，就可以通过mapping.txt的映射关系找到对应的类，方法，字段等。方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sdk\tools\proguard\bin 目录下有个retrace工具可以将混淆后的报错堆栈解码成正常的类名</span><br><span class="line">window下为retrace.bat，linux和mac为retrace.sh，</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用方法如下：</p>
<ul>
<li>将crash log保存为yourfilename.txt</li>
<li>拿到版本发布时生成的mapping.txt</li>
<li>执行命令retrace.bat -verbose mapping.txt yourfilename.txt</li>
</ul>
<p>所以我们每次打包版本都需要保存最新的mapping.txt文件。如果要使用到第三方的crash统计平台，比如bugly，还需要我们上传APP版本对应的mapping.txt.每次都要保存最新的mapping文件，那不就很麻烦？放心，gradle会帮到你，只需要在bulid.gradle加入下面的一句。每次我们编译的时候，都会自动帮你保存mapping文件到本地的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            if (variant.getBuildType().isMinifyEnabled()) &#123;</span><br><span class="line">                variant.assemble.doLast&#123;</span><br><span class="line">                        copy &#123;</span><br><span class="line">                            from variant.mappingFile</span><br><span class="line">                            into &quot;$&#123;projectDir&#125;/mappings&quot;</span><br><span class="line">                            rename &#123; String fileName -&gt;</span><br><span class="line">                                &quot;mapping-$&#123;variant.name&#125;.txt&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最后奉上近期项目中常用的混淆代码"><a href="#最后奉上近期项目中常用的混淆代码" class="headerlink" title="最后奉上近期项目中常用的混淆代码"></a>最后奉上近期项目中常用的混淆代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#下面是常见的proguard.cfg配置项</span><br><span class="line">#指定代码的压缩级别</span><br><span class="line">-optimizationpasses 5</span><br><span class="line">#包名不混合大小写</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line">#不去忽略非公共的库类</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"># 指定不去忽略非公共的库的类的成员</span><br><span class="line">-dontskipnonpubliclibraryclassmembers</span><br><span class="line">#优化  不优化输入的类文件</span><br><span class="line">-dontoptimize</span><br><span class="line">#预校验</span><br><span class="line">-dontpreverify</span><br><span class="line">#混淆时是否记录日志</span><br><span class="line">-verbose</span><br><span class="line"># 混淆时所采用的算法</span><br><span class="line">-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*</span><br><span class="line">#保护注解</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line">#忽略警告</span><br><span class="line">-ignorewarning</span><br><span class="line">#包明不混合大小写</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line">##记录生成的日志数据,gradle build时在本项目根目录输出##</span><br><span class="line">#apk 包内所有 class 的内部结构</span><br><span class="line">-dump class_files.txt</span><br><span class="line">#未混淆的类和成员-printseeds seeds.txt</span><br><span class="line">#列出从 apk 中删除的代码</span><br><span class="line">-printusage unused.txt</span><br><span class="line">#混淆前后的映射-printmapping mapping.txt</span><br><span class="line">#========================gson &amp; protobuf================================</span><br><span class="line">-dontwarn com.google.**</span><br><span class="line">-keep class com.google.gson.jsms.annotations.Until &#123;*;&#125;</span><br><span class="line">#如果用到Gson解析包的，直接添加下面这几行就能成功混淆，不然会报错</span><br><span class="line">#gson</span><br><span class="line">#-libraryjars libs/gson-2.2.4.jar</span><br><span class="line">-keepattributes Signature</span><br><span class="line"># Gson specific classes</span><br><span class="line">-keep class sun.misc.Unsafe &#123; *; &#125;</span><br><span class="line"># Application classes that will be serialized/deserialized over Gson</span><br><span class="line">-keep class com.google.gson.examples.android.model.** &#123; *; &#125;</span><br><span class="line"># -------------系统类不需要混淆 --------------------------</span><br><span class="line">-keep public class * extends android.app.Fragment</span><br><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Application</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class * extends android.support.**</span><br><span class="line">#如果有引用v4包可以添加下面这行</span><br><span class="line">-keep public class * extends android.support.v4.app.Fragment</span><br><span class="line"># 保留R下面的资源</span><br><span class="line">-keep class **.R$* &#123;*;&#125;</span><br><span class="line">#保持 native 方法不被混淆</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">  native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line">#保持自定义控件类不被混淆</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">  public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">      public void *ButtonClicked(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line">#保持自定义控件类不被混淆</span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">  public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line">##########JS接口类不混淆，否则执行不了</span><br><span class="line">-dontwarn com.android.JsInterface.**</span><br><span class="line">-keep class com.android.JsInterface.** &#123;*; &#125;</span><br><span class="line">-dontwarn org.apache.**</span><br><span class="line">-keep class org.apache.**&#123; *; &#125;</span><br><span class="line"># Glide 保护</span><br><span class="line">-keep public class * implements com.bumptech.glide.module.GlideModule</span><br><span class="line">-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123;</span><br><span class="line">**[] $VALUES;</span><br><span class="line">public *;</span><br><span class="line">&#125;</span><br><span class="line">#不混淆资源类</span><br><span class="line">-keepclassmembers class **.R$* &#123;</span><br><span class="line">      public static &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"># 泛型与反射</span><br><span class="line">-keepattributes Signature</span><br><span class="line">-keepattributes EnclosingMethod</span><br><span class="line">-keepattributes *Annotation*</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">######混淆保护自己项目的部分代码以及引用的第三方jar包library########</span><br><span class="line">#如果引用了v4或者v7包</span><br><span class="line">-dontwarn android.support.**</span><br><span class="line">#做v7包的混淆配置</span><br><span class="line">-dontwarn android.support.**</span><br><span class="line">-dontwarn android.support.v7.**</span><br><span class="line">-keep class android.support.v7.** &#123; *; &#125;</span><br><span class="line">-keep public class * extends android.support.v7.**</span><br><span class="line">-keep public class * extends android.support.v7.app.Fragment</span><br><span class="line">-dontwarn android.support.**</span><br><span class="line">-dontwarn android.support.v4.**</span><br><span class="line">-keep class android.support.v4.** &#123; *; &#125;</span><br><span class="line">-keep public class * extends android.support.v4.**</span><br><span class="line">-keep public class * extends android.support.v4.app.Fragment</span><br><span class="line">#Gson</span><br><span class="line">-keepattributes Signature</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keep class sun.misc.Unsafe &#123; *; &#125;</span><br><span class="line">-keep class com.google.gson.stream.** &#123; *; &#125;</span><br><span class="line"># Application classes that will be serialized/deserialized over Gson</span><br><span class="line">-keep class com.sunloto.shandong.bean.** &#123; *; &#125;</span><br><span class="line"># Jackson</span><br><span class="line">-dontwarn org.codehaus.jackson.**</span><br><span class="line">-dontwarn com.fasterxml.jackson.databind.**</span><br><span class="line">-keep class org.codehaus.jackson.** &#123; *;&#125;</span><br><span class="line">-keep class com.fasterxml.jackson.** &#123; *; &#125;</span><br><span class="line"></span><br><span class="line">#客户端代码中的JavaBean(实体类)的类名与其字段名称全部变成了a、b、c、d等等字符串，这与服务端返回的json字符串中的不一致，导致解析失败。所以，解决的办法是：在进行混淆编译进行打包apk的时候，过滤掉存放所有JavaBean（实体类)的包不进行混淆编译</span><br><span class="line">-keep class com.android.model.** &#123;*;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#保持第3方jar包不混淆</span><br><span class="line">-keep class io.reactivex.** &#123;*;&#125;</span><br><span class="line">-keep class com.hjhrq1991.library.** &#123;*;&#125;</span><br><span class="line">-dontwarn com.hjhrq1991.library.**</span><br><span class="line">-keep class com.github.** &#123;*;&#125;</span><br><span class="line">-keep class com.mcxiaoke.volley.** &#123;*;&#125;</span><br><span class="line">-keep class com.tencent.stat.** &#123;*;&#125;</span><br><span class="line">#universalimageloader图片加载框架不混淆</span><br><span class="line">-keep class com.nostra13.universalimageloader.** &#123; *; &#125;</span><br><span class="line">-dontwarn com.nostra13.universalimageloader.**</span><br><span class="line">-keep class cz.msebera.** &#123;*;&#125;</span><br><span class="line">-dontwarn cz.msebera.**</span><br><span class="line">-keep class com.jngis.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.jngis.**</span><br><span class="line">-keep class com.map.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.map.**</span><br><span class="line">-keep class org.kymjs.kjframe.**&#123;*;&#125;</span><br><span class="line">-dontwarn org.kymjs.kjframe.**</span><br><span class="line">-keep class org.json.**&#123;*;&#125;</span><br><span class="line">-keep class com.google.gson.**&#123;*;&#125;</span><br><span class="line">-keep class com.loopj.android.http.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.loopj.android.http.**</span><br><span class="line">-keep class com.google.zxing.**&#123;*;&#125;</span><br><span class="line">################xutils##################</span><br><span class="line">#-libraryjars libs/xUtils-2.6.14.jar</span><br><span class="line">-keep class com.lidroid.xutils.** &#123; *; &#125;</span><br><span class="line">-keep public class * extends com.lidroid.xutils.**</span><br><span class="line">-keepattributes Signature</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line">-keep public interface com.lidroid.xutils.** &#123;*;&#125;</span><br><span class="line">-dontwarn com.lidroid.xutils.**</span><br><span class="line">-keepclasseswithmembers class com.jph.android.entity.** &#123;</span><br><span class="line">    &lt;fields&gt;;</span><br><span class="line">    &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line">#极光推送</span><br><span class="line">-dontoptimize</span><br><span class="line">-dontpreverify</span><br><span class="line">-dontwarn cn.jpush.**</span><br><span class="line">-keep class cn.jpush.** &#123; *; &#125;</span><br><span class="line"># 高德相关依赖</span><br><span class="line"># 集合包:3D地图3.3.2 导航1.8.0 定位2.5.0</span><br><span class="line">-dontwarn com.amap.api.**</span><br><span class="line">-dontwarn com.autonavi.**</span><br><span class="line">-keep class com.amap.api.**&#123;*;&#125;</span><br><span class="line">-keep class com.autonavi.**&#123;*;&#125;</span><br><span class="line"># 地图服务</span><br><span class="line">-dontwarn com.amap.api.services.**</span><br><span class="line">-keep class com.map.api.services.** &#123;*;&#125;</span><br><span class="line"># 3D地图</span><br><span class="line">-dontwarn com.amap.api.mapcore.**</span><br><span class="line">-dontwarn com.amap.api.maps.**</span><br><span class="line">-dontwarn com.autonavi.amap.mapcore.**</span><br><span class="line">-keep class com.amap.api.mapcore.**&#123;*;&#125;</span><br><span class="line">-keep class com.amap.api.maps.**&#123;*;&#125;</span><br><span class="line">-keep class com.autonavi.amap.mapcore.**&#123;*;&#125;</span><br><span class="line"># 定位</span><br><span class="line">-dontwarn com.amap.api.location.**</span><br><span class="line">-dontwarn com.aps.**</span><br><span class="line">-keep class com.amap.api.location.**&#123;*;&#125;</span><br><span class="line">-keep class com.aps.**&#123;*;&#125;</span><br><span class="line"># 导航</span><br><span class="line">-dontwarn com.amap.api.navi.**</span><br><span class="line">-dontwarn com.autonavi.**</span><br><span class="line">-keep class com.amap.api.navi.** &#123;*;&#125;</span><br><span class="line">-keep class com.autonavi.** &#123;*;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#保持 Serializable 不被混淆</span><br><span class="line">-keepnames class * implements java.io.Serializable</span><br><span class="line">#保持 Serializable 不被混淆并且enum 类也不被混淆</span><br><span class="line">-keepclassmembers class * implements java.io.Serializable &#123;</span><br><span class="line">    static final long serialVersionUID;</span><br><span class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    !static !transient &lt;fields&gt;;</span><br><span class="line">    !private &lt;fields&gt;;</span><br><span class="line">    !private &lt;methods&gt;;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream);</span><br><span class="line">    private void readObject(java.io.ObjectInputStream);</span><br><span class="line">    java.lang.Object writeReplace();</span><br><span class="line">    java.lang.Object readResolve();</span><br><span class="line">&#125;</span><br><span class="line">#避免混淆泛型 如果混淆报错建议关掉</span><br><span class="line">-keepattributes Signature</span><br><span class="line">#移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用，另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制</span><br><span class="line">-assumenosideeffects class android.util.Log &#123;</span><br><span class="line">    public static *** v(...);</span><br><span class="line">    public static *** i(...);</span><br><span class="line">   public static *** d(...);</span><br><span class="line">    public static *** w(...);</span><br><span class="line">    public static *** e(...);</span><br><span class="line">&#125;</span><br><span class="line"># 讯飞语音</span><br><span class="line">-dontwarn com.iflytek.**</span><br><span class="line">-keep class com.iflytek.** &#123;*;&#125;</span><br><span class="line"># 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">void *(**On*Event);</span><br><span class="line">void *(**On*Listener);</span><br><span class="line">&#125;</span><br><span class="line"># webView处理，项目中没有使用到webView忽略即可</span><br><span class="line">-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123;</span><br><span class="line">public *;</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</span><br><span class="line">public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</span><br><span class="line">public boolean *(android.webkit.WebView, java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line">-keepclassmembers class * extends android.webkit.webViewClient &#123;</span><br><span class="line">public void *(android.webkit.webView, jav.lang.String);</span><br><span class="line">&#125;</span><br><span class="line">#其他</span><br><span class="line"># 源文件和行号的信息不混淆</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line"></span><br><span class="line"># 保留枚举类不被混淆</span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">public static **[] values();</span><br><span class="line">public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"># 抛出异常时保留代码行号</span><br><span class="line">-keepattributes SourceFile,LineNumberTable</span><br><span class="line"># 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。</span><br><span class="line">-dontpreverify</span><br><span class="line">-dontwarn  com.iflytek.sunflower.**</span><br><span class="line">-keep class  com.iflytek.sunflower.** &#123; *; &#125;</span><br><span class="line"># 保留Parcelable序列化类不被混淆</span><br><span class="line">-keep class * implements android.os.Parcelable &#123;</span><br><span class="line">public static final android.os.Parcelable$Creator *;</span><br><span class="line">&#125;</span><br><span class="line">#-dontwarn javax.annotation.**</span><br><span class="line">#-dontwarn javax.inject.**</span><br><span class="line"># OkHttp3</span><br><span class="line">-dontwarn com.squareup.okhttp.**</span><br><span class="line">-keep class com.squareup.okhttp.** &#123; *;&#125;</span><br><span class="line">-dontwarn okio.**</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#友盟分享</span><br><span class="line"> -dontusemixedcaseclassnames</span><br><span class="line">    -dontshrink</span><br><span class="line">    -dontoptimize</span><br><span class="line">    -dontwarn com.google.android.maps.**</span><br><span class="line">    -dontwarn android.webkit.WebView</span><br><span class="line">    -dontwarn com.umeng.**</span><br><span class="line">    -dontwarn com.tencent.weibo.sdk.**</span><br><span class="line">    -dontwarn com.facebook.**</span><br><span class="line">    -keep public class javax.**</span><br><span class="line">    -keep public class android.webkit.**</span><br><span class="line">    -dontwarn android.support.v4.**</span><br><span class="line">    -keep enum com.facebook.**</span><br><span class="line">    -keepattributes Exceptions,InnerClasses,Signature</span><br><span class="line">    -keepattributes *Annotation*</span><br><span class="line">    -keepattributes SourceFile,LineNumberTable</span><br><span class="line">    -keep public interface com.facebook.**</span><br><span class="line">    -keep public interface com.tencent.**</span><br><span class="line">    -keep public interface com.umeng.socialize.**</span><br><span class="line">    -keep public interface com.umeng.socialize.sensor.**</span><br><span class="line">    -keep public interface com.umeng.scrshot.**</span><br><span class="line">    -keep class com.android.dingtalk.share.ddsharemodule.** &#123; *; &#125;</span><br><span class="line">    -keep public class com.umeng.socialize.* &#123;*;&#125;</span><br><span class="line">    -keep class com.facebook.**</span><br><span class="line">    -keep class com.facebook.** &#123; *; &#125;</span><br><span class="line">    -keep class com.umeng.scrshot.**</span><br><span class="line">    -keep public class com.tencent.** &#123;*;&#125;</span><br><span class="line">    -keep class com.umeng.socialize.sensor.**</span><br><span class="line">    -keep class com.umeng.socialize.handler.**</span><br><span class="line">    -keep class com.umeng.socialize.handler.*</span><br><span class="line">    -keep class com.umeng.weixin.handler.**</span><br><span class="line">    -keep class com.umeng.weixin.handler.*</span><br><span class="line">    -keep class com.umeng.qq.handler.**</span><br><span class="line">    -keep class com.umeng.qq.handler.*</span><br><span class="line">    -keep class UMMoreHandler&#123;*;&#125;</span><br><span class="line">    -keep class com.tencent.mm.sdk.modelmsg.WXMediaMessage &#123;*;&#125;</span><br><span class="line">    -keep class com.tencent.mm.sdk.modelmsg.** implements   com.tencent.mm.sdk.modelmsg.WXMediaMessage$IMediaObject &#123;*;&#125;</span><br><span class="line">    -keep class im.yixin.sdk.api.YXMessage &#123;*;&#125;</span><br><span class="line">    -keep class im.yixin.sdk.api.** implements im.yixin.sdk.api.YXMessage$YXMessageData&#123;*;&#125;</span><br><span class="line">    -keep class com.tencent.mm.sdk.** &#123;</span><br><span class="line">     *;</span><br><span class="line">    &#125;</span><br><span class="line">    -keep class com.tencent.mm.opensdk.** &#123;</span><br><span class="line">   *;</span><br><span class="line">    &#125;</span><br><span class="line">    -dontwarn twitter4j.**</span><br><span class="line">    -keep class twitter4j.** &#123; *; &#125;</span><br><span class="line">    -keep class com.tencent.** &#123;*;&#125;</span><br><span class="line">    -dontwarn com.tencent.**</span><br><span class="line">    -keep public class com.umeng.com.umeng.soexample.R$*&#123;</span><br><span class="line">    public static final int *;</span><br><span class="line">    &#125;</span><br><span class="line">    -keep public class com.linkedin.android.mobilesdk.R$*&#123;</span><br><span class="line">    public static final int *;</span><br><span class="line">        &#125;</span><br><span class="line">    -keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">    &#125;</span><br><span class="line">    -keep class com.tencent.open.TDialog$*</span><br><span class="line">    -keep class com.tencent.open.TDialog$* &#123;*;&#125;</span><br><span class="line">    -keep class com.tencent.open.PKDialog</span><br><span class="line">    -keep class com.tencent.open.PKDialog &#123;*;&#125;</span><br><span class="line">    -keep class com.tencent.open.PKDialog$*</span><br><span class="line">    -keep class com.tencent.open.PKDialog$* &#123;*;&#125;</span><br><span class="line">    -keep class com.sina.** &#123;*;&#125;</span><br><span class="line">    -dontwarn com.sina.**</span><br><span class="line">    -keep class  com.alipay.share.sdk.** &#123;</span><br><span class="line">       *;</span><br><span class="line">    &#125;</span><br><span class="line">    -keepnames class * implements android.os.Parcelable &#123;</span><br><span class="line">    public static final ** CREATOR;</span><br><span class="line">    &#125;</span><br><span class="line">    -keep class com.linkedin.** &#123; *; &#125;</span><br><span class="line">    -keepattributes Signature</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 代码混淆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webview详解和常见的问题]]></title>
      <url>/2017/05/26/webview%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>WebView与js的交互包含两方面,一是在html中通过js调用java代码；二是在安卓java代码中调用js。<br><a id="more"></a><br>1.如果访问的界面中有JavaScript，则webview必须支持javascript。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSetting = webview.getSetting();</span><br><span class="line"> webSetting.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p>
<p>2.如果页面中链接，如果希望点击链接继续在当前browser中响应，而不是新开Android的系统browser中响应该链接，必须覆盖webview的WebViewClient对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setWebViewClient(new WebViewClient()&#123;</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;      </span><br><span class="line">        view.loadUrl(url);      </span><br><span class="line">        return true;      </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.如果不做任何处理，浏览网页，点击系统“Back”键，整个Browser会调用finish()而结束自身，如果希望浏览的网页回退而不是推出浏览器，需要在当前Activity中处理并消费掉该Back事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean onKeyDown(int keyCode, KeyEventevent) &#123;      </span><br><span class="line">           if((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123;      </span><br><span class="line">               mWebView.goBack();      </span><br><span class="line">               return true;      </span><br><span class="line">           &#125;      </span><br><span class="line">        return super.onKeyDown(keyCode, event);      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>4.如果webView中需要用户手动输入用户名、密码或其他，则webview必须设置支持获取手势焦点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webview.requestFocusFromTouch();</span><br></pre></td></tr></table></figure></p>
<p>5.原来是因为WebView默认没有开启文件下载的功能，如果要实现文件下载的功能，需要设置WebView的DownloadListener，通过实现自己的DownloadListener来实现文件的下载。具体操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、设置WebView的DownloadListener：</span><br><span class="line">    webView.setDownloadListener(new MyWebViewDownLoadListener());</span><br><span class="line">2、实现MyWebViewDownLoadListener这个类，具体可以如下这样：    </span><br><span class="line">    private class MyWebViewDownLoadListener implements DownloadListener &#123;  </span><br><span class="line">        @Override  </span><br><span class="line">        public void onDownloadStart(String url, String userAgent, String </span><br><span class="line">        contentDisposition, String mimeType, long contentLength) &#123;  </span><br><span class="line">        Uri uri = Uri.parse(url);  </span><br><span class="line">        Intent intent = new Intent(Intent.ACTION_VIEW, uri);  </span><br><span class="line">        startActivity(intent);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">这只是调用系统中已经内置的浏览器进行下载，还没有WebView本身进行的文件下载，</span><br><span class="line">不过，这也基本上满足我们的应用场景了。</span><br></pre></td></tr></table></figure></p>
<p>WebSettings的常用方法介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1.setJavaScriptEnabled(true);</span><br><span class="line">//支持js脚步</span><br><span class="line"></span><br><span class="line">2.setPluginsEnabled(true);</span><br><span class="line">//支持插件</span><br><span class="line"></span><br><span class="line">3.setUseWideViewPort(false);</span><br><span class="line">//将图片调整到适合webview的大小</span><br><span class="line"></span><br><span class="line">4.setSupportZoom(true);</span><br><span class="line">//支持变焦控制和手势缩放</span><br><span class="line"></span><br><span class="line">5.setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN);</span><br><span class="line">//支持内容从新布局</span><br><span class="line"></span><br><span class="line">6.supportMultipleWindows();</span><br><span class="line">//多窗口</span><br><span class="line"></span><br><span class="line">7.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class="line">//关闭webview中缓存</span><br><span class="line"></span><br><span class="line">8.setAllowFileAccess(true);</span><br><span class="line">//设置可以访问文件</span><br><span class="line"></span><br><span class="line">9.setNeedInitialFocus(true);</span><br><span class="line">//当webview调用requestFocus时为webview设置节点</span><br><span class="line"></span><br><span class="line">10.setBuiltInZoomControls(true);</span><br><span class="line">//Sets whether the WebView should use its built-in zoom mechanisms.设置其webview内置的缩放机制</span><br><span class="line"></span><br><span class="line">11.setJavaScriptCanOpenWindowsAutomatically(true);</span><br><span class="line">//支持通过JS打开新窗口</span><br><span class="line"></span><br><span class="line">12.setLoadsImagesAutomatically(true);</span><br><span class="line">//支持自动加载图片</span><br></pre></td></tr></table></figure></p>
<p>WebViewClient的方法全解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.doUpdateVisitedHistory(WebViewview,Stringurl, boolean isReload)</span><br><span class="line">(更新历史记录)</span><br><span class="line">2.onFormResubmission(WebViewview,MessagedontResend,Messageresend)</span><br><span class="line">(应用程序重新请求网页数据)</span><br><span class="line">3.onLoadResource(WebViewview,Stringurl)</span><br><span class="line">在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。</span><br><span class="line">4.onPageStarted(WebViewview,Stringurl,Bitmapfavicon)</span><br><span class="line">这个事件就是开始载入页面调用的，通常我们可以在这设定一个loading的页面，告诉用户程序在等待网络响应。</span><br><span class="line">5.onPageFinished(WebViewview,Stringurl)</span><br><span class="line">在页面加载结束时调用。同样道理，我们知道一个页面载入完成，于是我们可以关闭loading 条，切换程序动作。</span><br><span class="line">6.onReceivedError(WebViewview, int errorCode, Stringdescription,StringfailingUrl)</span><br><span class="line">(报告错误信息)</span><br><span class="line">7.onReceivedHttpAuthRequest(WebViewview,HttpAuthHandlerhandler,Stringhost,Stringrealm)</span><br><span class="line">（获取返回信息授权请求）</span><br><span class="line">8.onReceivedSslError(WebViewview,SslErrorHandlerhandler,SslErrorerror)</span><br><span class="line">重写此方法可以让webview处理https请求。</span><br><span class="line">9.onScaleChanged(WebViewview, float oldScale, float newScale)</span><br><span class="line">(WebView发生改变时调用)</span><br><span class="line">10.onUnhandledKeyEvent(WebViewview,KeyEventevent)</span><br><span class="line">（Key事件未被加载时调用）</span><br><span class="line">11.shouldOverrideKeyEvent(WebViewview,KeyEventevent)</span><br><span class="line">重写此方法才能够处理在浏览器中的按键事件。</span><br><span class="line">12.shouldOverrideUrlLoading(WebViewview,Stringurl)</span><br><span class="line">在点击请求的是链接是才会调用，重写此方法返回true表明点击网页里面的链接还是在当前的webview里跳转，不跳到浏览器那边。这个函数</span><br><span class="line">我们可以做很多操作，比如我们读取到某些特殊的URL，于是就可以不打开地址，取消这个操作，进行预先定义的其他操作。</span><br></pre></td></tr></table></figure></p>
<p>常用步骤</p>
<p>1、添加上网权限：</p>
<p>2、设置webview<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WebView webView = new WebView(this);</span><br><span class="line">WebSettings ws = webView.getSettings();</span><br><span class="line">ws.setAppCacheEnabled(true);// 设置启动缓存</span><br><span class="line">ws.setAppCacheMaxSize(1024 * 10);// 设置最大缓存</span><br><span class="line">ws.setSupportZoom(true);// 设置支持缩放</span><br><span class="line">ws.setBuiltInZoomControls(true);</span><br><span class="line">ws.setCacheMode(WebSettings.LOAD_NO_CACHE);// 设置缓存模式</span><br><span class="line">// 设置支持Javascript</span><br><span class="line">ws.setJavaScriptEnabled(true);</span><br><span class="line">ws.setJavaScriptCanOpenWindowsAutomatically(true);</span><br><span class="line">// 缓存，离线应用</span><br><span class="line">ws.setAppCacheEnabled(true);</span><br><span class="line">ws.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">ws.setAppCacheMaxSize(1024 * 1024 * 8);</span><br></pre></td></tr></table></figure></p>
<p>3、获取网页对话框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;</span><br><span class="line">    @Overridepublic boolean onJsAlert(WebView view, String url, String message,final JsResult result) &#123;</span><br><span class="line">    //构建一个Builder来显示网页中的对话框Builder builder = new Builder(context);</span><br><span class="line">        builder.setTitle(&quot;警告&quot;);</span><br><span class="line">        builder.setMessage(message);</span><br><span class="line">        builder.setPositiveButton(android.R.string.ok,new AlertDialog.OnClickListener() &#123;</span><br><span class="line">            public void onClick(DialogInterface dialog,int which) &#123;// 点击确定按钮之后,继续执行网页中的操作</span><br><span class="line">            result.confirm();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        builder.setCancelable(false);</span><br><span class="line">        builder.create();</span><br><span class="line">        builder.show();return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Overridepublic boolean onJsConfirm(WebView view, String url,</span><br><span class="line">    String message, final JsResult result) &#123;// TODO Auto-generated method stub</span><br><span class="line">        Builder builder = new Builder(context);</span><br><span class="line">        builder.setTitle(&quot;confirm&quot;);</span><br><span class="line">        builder.setMessage(message);</span><br><span class="line">        builder.setPositiveButton(android.R.string.ok,new AlertDialog.OnClickListener() &#123;</span><br><span class="line">            public void onClick(DialogInterface dialog,int which) &#123;</span><br><span class="line">                result.confirm();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        builder.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            public void onClick(DialogInterface dialog,int which) &#123;</span><br><span class="line">                result.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        builder.setCancelable(false);</span><br><span class="line">        builder.create();</span><br><span class="line">        builder.show();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Overridepublic void onProgressChanged(WebView view, int newProgress) &#123;// 加载进度//</span><br><span class="line">        super.onProgressChanged(view, newProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>4、如果希望点击链接由自己处理，而不是新开Android的系统browser中响应该链接。<br>给WebView添加一个事件监听对象(WebViewClient)</p>
<p>5、webview取得焦点</p>
<p>6、提示加载对话框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd=ProgressDialog.show(context, &quot;请稍后&quot;, &quot;正在加载中...&quot;);</span><br><span class="line">当网页加载完成后，调用pd.dismiss();</span><br></pre></td></tr></table></figure></p>
<p>webview和js之间数据的传送操作</p>
<p>Webview与js交互</p>
<p>Webview与js的双向交互才是android的webview强大所在，也是马甲精神能够彻底执行的基础保障。<br>将WebView接受到的数据传递给js<br>首先，webview可以定义一个在其内嵌页面中可以触发的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wv.addJavascriptInterface(new DemoJavaScriptInterface(), &quot;demo&quot;);</span><br><span class="line">private final class DemoJavaScriptInterface &#123;  </span><br><span class="line">    public void clickonAndroid( final String order)&#123;  </span><br><span class="line">        mHandler.post(new Runnable()&#123;  </span><br><span class="line">            @Override  </span><br><span class="line">             public void run()&#123;  </span><br><span class="line">                 sonText=&quot;&#123;&quot;name&quot;:&quot;&quot;+order+&quot;&quot;&#125;&quot;;  </span><br><span class="line">                 wv.loadUrl(&quot;javascript:wave(&quot;+jsonText+&quot;)&quot;);  </span><br><span class="line">             &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将js接受到的数据传递给webview<br>如果你想获取页面的一些处理数据并交给webview客户端处理，可在wave函数里将数据alert，然后webview中重写WebChromeClient的onJsAlert函数，具体代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wv.setWebChromeClient(new MyWebChromeClient());  </span><br><span class="line">final  class MyWebChromeClient extends WebChromeClient&#123;  </span><br><span class="line">//message就是wave函数里alert的字符串，这样你就可以在android客户端里对这个数据进行处理  </span><br><span class="line">    @Override </span><br><span class="line">    public boolean onJsAlert(WebView view, String url, String message, final JsResult result) &#123;</span><br><span class="line">        result.confirm(); </span><br><span class="line">        return true;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>loadData和loadDataWithBaseURL区别</p>
<p>loadData (String data, String mimeType, String encoding)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载一段HTML代码时，如果出现中文乱码问题，</span><br><span class="line">就写成loadData(String data, &quot;text/html;charset=UTF-8&quot;,null)</span><br></pre></td></tr></table></figure></p>
<p>loadDataWithBaseURL (String baseUrl, String data, String mimeType, String encoding, String historyUrl)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadDataWithBaseURL()比loadData()多两个参数，可以指定HTML代码片段中相关资源的相对根路径，也可以指定历史Url。</span><br><span class="line">两个方法的其余三个参数相同。</span><br><span class="line">其次，两个方法加载的HTML代码片段有些不同，loadData()中的html data中不能包含&apos;#&apos;, &apos;%&apos;, &apos;\&apos;, &apos;?&apos;四中特殊字符,这</span><br></pre></td></tr></table></figure></p>
<p>WebView加载本地的css文件，js文件和图片，主要是覆盖WebViewClient中的shouldInterceptRequest（View view， String url）方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cacheWebview.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123;</span><br><span class="line"></span><br><span class="line">            WebResourceResponse response = super.shouldInterceptRequest(view, url);</span><br><span class="line"></span><br><span class="line">            if (url.contains(&quot;weixin_qrcode_258.jpg&quot;))&#123;</span><br><span class="line">                InputStream inputStream = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    inputStream = getResources().getAssets().open(&quot;weixin_qrcode_258.jpg&quot;);</span><br><span class="line">                    response = new WebResourceResponse(&quot;image/png&quot;,</span><br><span class="line">                            &quot;utf-8&quot;, inputStream);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else if(url.contains(jsName))&#123;</span><br><span class="line">               InputStream is = appRm.getInputStream(R.raw.jquery_min_js);</span><br><span class="line">               WebResourceResponse response = new WebResourceResponse(&quot;text/javascript&quot;,&quot;utf-8&quot;, is);</span><br><span class="line">            &#125;else if(url.contains(cssName))&#123;</span><br><span class="line">               InputStream is = appRm.getInputStream(R.raw.css;</span><br><span class="line">               WebResourceResponse response = new WebResourceResponse(&quot;text/css&quot;,&quot;utf-8&quot;, is);</span><br><span class="line">            &#125;</span><br><span class="line">            return response;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>加载assets文件夹下面的html资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(&quot;file:///android_asset/1.html&quot;);</span><br></pre></td></tr></table></figure></p>
<p>调用js可能出现的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Alert无法弹出</span><br><span class="line">你应该是没有设置WebChromeClient,按照以下代码设置</span><br><span class="line">myWebView.setWebChromeClient(new WebChromeClient() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">Uncaught ReferenceError: functionName is not defined</span><br><span class="line">问题出现原因，网页的js代码没有加载完成，就调用了js方法。解决方法是在网页加载完成之后调用js方法</span><br><span class="line">myWebView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">      super.onPageFinished(view, url);</span><br><span class="line">      //在这里执行你想调用的js函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android面试总结]]></title>
      <url>/2017/05/19/Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>整理一些常见的Android面试题（针对于2~3年开发经验中所遇到的问题）<br><a id="more"></a><br>android阿里面试题锦集（<a href="http://www.jianshu.com/p/cf5092fa2694" target="_blank" rel="noopener">点击查看</a>）</p>
<h3 id="1：Activity生命周期？"><a href="#1：Activity生命周期？" class="headerlink" title="1：Activity生命周期？"></a>1：Activity生命周期？</h3><p>这几乎是个老少咸宜，永远不会过时的问题，而且极有可能是第一个问题。这个问题当然没什么好讲的啦，死记硬背是没什么用的了，关键是理解。本人就曾遇到这个问题的变种问题，问onStart(),与onResume()有什么区别？如果面试官抛出这个问题，是不是有点措手不及。今天又听说有同学遭遇了更变态的问题：什么情况下Activity走了onCreat()，而不走onStart()，这简直就是脑筋急转弯嘛。</p>
<h3 id="2：service生命周期？"><a href="#2：service生命周期？" class="headerlink" title="2：service生命周期？"></a>2：service生命周期？</h3><p>这里要注意service有两种启动方式，startService()和bindService()<br><img src="http://upload-images.jianshu.io/upload_images/1187237-4cbfd0f464cd5313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="3：如何理解Activity，View，Window三者之间的关系？"><a href="#3：如何理解Activity，View，Window三者之间的关系？" class="headerlink" title="3：如何理解Activity，View，Window三者之间的关系？"></a>3：如何理解Activity，View，Window三者之间的关系？</h3><p>这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。</p>
<ul>
<li>1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。</li>
<li>2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。</li>
<li>3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等</li>
<li>4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。<br>WindowManagerService</li>
<li>Activity：Activity包罗一个Window，该Window在Activity的attach要领中经由过程挪用</li>
<li>PolicyManager.makeNewWindo建立；</li>
<li>View：最根本的UI组件，表现屏幕上的一个矩形区域；</li>
<li>DecorView：是Window中View的RootView，设置窗口属性；</li>
<li>Window：表现顶层窗口，治理界面的显示和事务的响应；每个Activity 均会建立一个PhoneWindow工具，是Activity和全部View体系交互的接口</li>
<li>WindowManager：一个interface，继续自ViewManager。地点运用历程的窗口治理器；</li>
<li>有一个implementation WindowManagerImpl；</li>
</ul>
<p>重要用来治理窗口的一些状况、属性、view增添、删除、更新、窗口次序、新闻网络和处置惩罚等。</p>
<p>ViewRoot：经由过程IWindowSession接口与全局窗口治理器举行交互：界面掌握和新闻响应；</p>
<p>ActivityThread：运用法式的主线程，个中会建立联系关系当前Activity与Window；</p>
<p>建立WIndowManager实现类实例，把当前DecoView参加到WindowManager；</p>
<h3 id="4：Activity的几种LaunchMode及使用场景"><a href="#4：Activity的几种LaunchMode及使用场景" class="headerlink" title="4：Activity的几种LaunchMode及使用场景"></a>4：Activity的几种LaunchMode及使用场景</h3><ul>
<li>standard 模式</li>
<li>这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。</li>
<li>singleTop 模式</li>
<li>如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。</li>
<li>singleTask 模式</li>
<li>如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</li>
<li>singleInstance 模式</li>
<li>在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</li>
</ul>
<h3 id="5：View的绘制流程（点击查看）"><a href="#5：View的绘制流程（点击查看）" class="headerlink" title="5：View的绘制流程（点击查看）"></a>5：View的绘制流程（<a href="http://blog.csdn.net/yanbober/article/details/46128379/" target="_blank" rel="noopener">点击查看</a>）</h3><ul>
<li>measure过程</li>
<li>layout过程</li>
<li>draw过程</li>
</ul>
<h3 id="6：Touch事件的传递机制"><a href="#6：Touch事件的传递机制" class="headerlink" title="6：Touch事件的传递机制"></a>6：Touch事件的传递机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publicbooleandispatchTouchEvent(MotionEventev);  //用来分派event</span><br><span class="line">publicbooleanonInterceptTouchEvent(MotionEventev);//用来拦截event</span><br><span class="line">publicbooleanonTouchEvent(MotionEventev);//用来处理event</span><br></pre></td></tr></table></figure>
<p>其中Activity和View控件（TextView）拥有分派和处理事件方法，View容器（LinearLayout）具有分派，拦截，处理事件方法。这里也有个比喻：领导都会把任务向下分派，一旦下面的人把事情做不好，就不会再把后续的任务交给下面的人来做了，只能自己亲自做，如果自己也做不了，就只能告诉上级不能完成任务，上级又会重复他的过程。另外，领导都有权利拦截任务，对下级隐瞒该任务，而直接自己去做，如果做不成，也只能向上级报告不能完成任务。</p>
<p><a href="http://gold.xitu.io/entry/56af0ba0c24aa800547b60ea" target="_blank" rel="noopener">http://gold.xitu.io/entry/56af0ba0c24aa800547b60ea</a><br><a href="http://blog.csdn.net/morgan_xww/article/details/9372285" target="_blank" rel="noopener">http://blog.csdn.net/morgan_xww/article/details/9372285</a></p>
<h3 id="7：Android中的几种动画"><a href="#7：Android中的几种动画" class="headerlink" title="7：Android中的几种动画"></a>7：Android中的几种动画</h3><p>曾被问到Android中有几种动画，这个问题也好难回答。Android3.0之前有2种，3.0后有3种。<br>FrameAnimation（逐帧动画）：将多张图片组合起来进行播放，类似于早期电影的工作原理，很多App的loading是采用这种方式。<br>TweenAnimation（补间动画）：是对某个View进行一系列的动画的操作，包括淡入淡出（Alpha），缩放（Scale），平移（Translate），旋转（Rotate）四种模式。<br>PropertyAnimation（属性动画）：属性动画不再仅仅是一种视觉效果了，而是一种不断地对值进行操作的机制，并将值赋到指定对象的指定属性上，可以是任意对象的任意属性。<br><a href="http://blog.csdn.net/yanbober/article/details/46481171" target="_blank" rel="noopener">http://blog.csdn.net/yanbober/article/details/46481171</a></p>
<h3 id="8：Android中跨进程通讯有几种方式"><a href="#8：Android中跨进程通讯有几种方式" class="headerlink" title="8：Android中跨进程通讯有几种方式"></a>8：Android中跨进程通讯有几种方式</h3><p>1：访问其他应用程序的Activity<br>如调用系统通话应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntentcallIntent=newIntent(Intent.ACTION_CALL,Uri.parse(&quot;tel:12345678&quot;);</span><br><span class="line">startActivity(callIntent);</span><br></pre></td></tr></table></figure></p>
<p>2：Content Provider<br>如访问系统相册</p>
<p>3：广播（Broadcast）<br>如显示系统时间</p>
<p>4：AIDL服务</p>
<h3 id="9：AIDL理解"><a href="#9：AIDL理解" class="headerlink" title="9：AIDL理解"></a>9：AIDL理解</h3><p><a href="http://bbs.51cto.com/thread-1086040-1.html" target="_blank" rel="noopener">http://bbs.51cto.com/thread-1086040-1.html</a></p>
<h3 id="10：Handler的原理"><a href="#10：Handler的原理" class="headerlink" title="10：Handler的原理"></a>10：Handler的原理</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/38377229</a></p>
<h3 id="11：Binder机制原理"><a href="#11：Binder机制原理" class="headerlink" title="11：Binder机制原理"></a>11：Binder机制原理</h3><p><a href="http://blog.csdn.net/boyupeng/article/details/47011383" target="_blank" rel="noopener">http://blog.csdn.net/boyupeng/article/details/47011383</a></p>
<h3 id="12：热修复的原理"><a href="#12：热修复的原理" class="headerlink" title="12：热修复的原理"></a>12：热修复的原理</h3><ul>
<li>1：JavaSisst</li>
<li>2：AspectJ</li>
<li>3：Xposef<br>这里给出Xposef方案<br><a href="http://mp.weixin.qq.com/s?__biz=MzA3Mjk1MjA4Nw==&amp;mid=400452659&amp;idx=1&amp;sn=841b49b875ec3b307f261ed52a7d9c4e&amp;scene=23&amp;srcid=1119JWRt0adNwGxTHiyok460#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA3Mjk1MjA4Nw==&amp;mid=400452659&amp;idx=1&amp;sn=841b49b875ec3b307f261ed52a7d9c4e&amp;scene=23&amp;srcid=1119JWRt0adNwGxTHiyok460#rd</a></li>
</ul>
<h3 id="13：设计一套图片异步加载缓存方案"><a href="#13：设计一套图片异步加载缓存方案" class="headerlink" title="13：设计一套图片异步加载缓存方案"></a>13：设计一套图片异步加载缓存方案</h3><p><a href="http://www.cnblogs.com/zyw-205520/p/4997863.html" target="_blank" rel="noopener">http://www.cnblogs.com/zyw-205520/p/4997863.html</a><br><a href="http://blog.csdn.net/boyupeng/article/details/47127605" target="_blank" rel="noopener">http://blog.csdn.net/boyupeng/article/details/47127605</a></p>
<h3 id="14：Android内存泄露及管理"><a href="#14：Android内存泄露及管理" class="headerlink" title="14：Android内存泄露及管理"></a>14：Android内存泄露及管理</h3><p><a href="http://gold.xitu.io/entry/56d64b9e816dfa005943a55c" target="_blank" rel="noopener">http://gold.xitu.io/entry/56d64b9e816dfa005943a55c</a></p>
<h3 id="15：Activity与Fragment通信"><a href="#15：Activity与Fragment通信" class="headerlink" title="15：Activity与Fragment通信"></a>15：Activity与Fragment通信</h3><p><a href="http://gold.xitu.io/entry/56a87b2b2e958a0051906227" target="_blank" rel="noopener">http://gold.xitu.io/entry/56a87b2b2e958a0051906227</a></p>
<h3 id="16：Fragment的那些坑"><a href="#16：Fragment的那些坑" class="headerlink" title="16：Fragment的那些坑"></a>16：Fragment的那些坑</h3><p><a href="http://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="noopener">http://www.jianshu.com/p/d9143a92ad94</a><br><a href="http://www.jianshu.com/p/fd71d65f0ec6" target="_blank" rel="noopener">http://www.jianshu.com/p/fd71d65f0ec6</a><br><a href="http://www.jianshu.com/p/38f7994faa6b" target="_blank" rel="noopener">http://www.jianshu.com/p/38f7994faa6b</a></p>
<h3 id="16：Android-UI适配"><a href="#16：Android-UI适配" class="headerlink" title="16：Android UI适配"></a>16：Android UI适配</h3><p>这里给出hongyang大神的方案<br><a href="http://blog.csdn.net/lmj623565791/article/details/45460089" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/45460089</a></p>
<h3 id="17：布局优化"><a href="#17：布局优化" class="headerlink" title="17：布局优化"></a>17：布局优化</h3><p><a href="http://www.jianshu.com/p/145fc61011cd" target="_blank" rel="noopener">http://www.jianshu.com/p/145fc61011cd</a></p>
<h3 id="18：Http-Https"><a href="#18：Http-Https" class="headerlink" title="18：Http Https"></a>18：Http Https</h3><p><a href="http://www.jianshu.com/p/93fdebe5fef1" target="_blank" rel="noopener">http://www.jianshu.com/p/93fdebe5fef1</a></p>
<h3 id="19：网络请求优化"><a href="#19：网络请求优化" class="headerlink" title="19：网络请求优化"></a>19：网络请求优化</h3><p><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="noopener">http://www.jianshu.com/p/3141d4e46240</a></p>
<h3 id="20：数据库优化"><a href="#20：数据库优化" class="headerlink" title="20：数据库优化"></a>20：数据库优化</h3><p><a href="http://www.jianshu.com/p/3b4452fc1bbd" target="_blank" rel="noopener">http://www.jianshu.com/p/3b4452fc1bbd</a></p>
<h3 id="21：图片优化"><a href="#21：图片优化" class="headerlink" title="21：图片优化"></a>21：图片优化</h3><p><a href="http://www.jianshu.com/p/5bb8c01e2bc7" target="_blank" rel="noopener">http://www.jianshu.com/p/5bb8c01e2bc7</a></p>
<h3 id="22：HybridJAVA-与JS交互"><a href="#22：HybridJAVA-与JS交互" class="headerlink" title="22：HybridJAVA 与JS交互"></a>22：HybridJAVA 与JS交互</h3><p><a href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/" target="_blank" rel="noopener">http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/</a></p>
<h3 id="23：单例"><a href="#23：单例" class="headerlink" title="23：单例"></a>23：单例</h3><p><a href="http://www.jianshu.com/p/a956024629cb" target="_blank" rel="noopener">http://www.jianshu.com/p/a956024629cb</a></p>
<h3 id="24：Java-GC原理"><a href="#24：Java-GC原理" class="headerlink" title="24：Java GC原理"></a>24：Java GC原理</h3><p><a href="http://www.jianshu.com/p/d75a32ac5bed?" target="_blank" rel="noopener">http://www.jianshu.com/p/d75a32ac5bed?</a></p>
<h3 id="25：ANR"><a href="#25：ANR" class="headerlink" title="25：ANR"></a>25：ANR</h3><p><a href="http://www.jianshu.com/p/124f3b75e164" target="_blank" rel="noopener">http://www.jianshu.com/p/124f3b75e164</a></p>
<h3 id="26：Volley"><a href="#26：Volley" class="headerlink" title="26：Volley"></a>26：Volley</h3><p><a href="http://www.jianshu.com/p/9e17727f31a1" target="_blank" rel="noopener">http://www.jianshu.com/p/9e17727f31a1</a></p>
<h3 id="27：JAVA注解反射原理"><a href="#27：JAVA注解反射原理" class="headerlink" title="27：JAVA注解反射原理"></a>27：JAVA注解反射原理</h3><p><a href="http://www.jianshu.com/p/3968ffabdf9d" target="_blank" rel="noopener">http://www.jianshu.com/p/3968ffabdf9d</a></p>
<h3 id="28：算法"><a href="#28：算法" class="headerlink" title="28：算法"></a>28：算法</h3><p><a href="http://www.jianshu.com/p/ae97c3ceea8d" target="_blank" rel="noopener">http://www.jianshu.com/p/ae97c3ceea8d</a></p>
<h3 id="29：设计模式"><a href="#29：设计模式" class="headerlink" title="29：设计模式"></a>29：设计模式</h3><p><a href="http://gold.xitu.io/entry/56ebb4ad5bbb50004c440972" target="_blank" rel="noopener">http://gold.xitu.io/entry/56ebb4ad5bbb50004c440972</a></p>
<h3 id="30：RxJava"><a href="#30：RxJava" class="headerlink" title="30：RxJava"></a>30：RxJava</h3><p><a href="http://gank.io/post/560e15be2dca930e00da1083?from=timeline&amp;isappinstalled=0#toc_1" target="_blank" rel="noopener">http://gank.io/post/560e15be2dca930e00da1083?from=timeline&amp;isappinstalled=0#toc_1</a></p>]]></content>
      
        
        <tags>
            
            <tag> android 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android面试总结(问答篇)]]></title>
      <url>/2017/03/15/Android%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E9%97%AE%E7%AD%94)/</url>
      <content type="html"><![CDATA[<p>整理一些常见的Android面试题（针对于2~3年开发经验中所遇到的问题）<br><a id="more"></a></p>
<h3 id="synchronized锁静态方法和非静态方法的区别"><a href="#synchronized锁静态方法和非静态方法的区别" class="headerlink" title="synchronized锁静态方法和非静态方法的区别"></a>synchronized锁静态方法和非静态方法的区别</h3><ul>
<li>非静态方法:<br>给对象加锁(可以理解为给这个对象的内存上锁,注意 只是这块内存,其他同类对象都会有各自的内存锁),这时候<br>在其他一个以上线程中执行该对象的这个同步方法(注意:是该对象)就会产生互斥 <ul>
<li>静态方法:<br>相当于在类上加锁(*.class 位于代码区,静态方法位于静态区域,这个类产生的对象公用这个静态方法,所以这块<br>内存，N个对象来竞争), 这时候,只要是这个类产生的对象,在调用这个静态方法时都会产生互斥 </li>
</ul>
</li>
</ul>
<h3 id="int-和Integer的区别"><a href="#int-和Integer的区别" class="headerlink" title="int 和Integer的区别"></a>int 和Integer的区别</h3><p>1、Integer是int提供的封装类，而int是Java的基本数据类型；</p>
<p>2、Integer默认值是null，而int默认值是0；</p>
<p>3、声明为Integer的变量需要实例化，而声明为int的变量不需要实例化；</p>
<p>4、Integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数值。</p>
<h3 id="内存泄漏有哪些？原因？"><a href="#内存泄漏有哪些？原因？" class="headerlink" title="内存泄漏有哪些？原因？"></a>内存泄漏有哪些？原因？</h3><ul>
<li>1.资源对象没关闭造成的内存泄漏</li>
<li>2.构造Adapter时，没有使用缓存的convertView</li>
<li>3.Bitmap对象不在使用时调用recycle()释放内存</li>
<li>4.试着使用关于application的context来替代和activity相关的context</li>
<li>5.注册没取消造成的内存泄漏</li>
<li>6.集合中对象没清理造成的内存泄漏</li>
</ul>
<h3 id="卡顿的根本原因？怎么处理？"><a href="#卡顿的根本原因？怎么处理？" class="headerlink" title="卡顿的根本原因？怎么处理？"></a>卡顿的根本原因？怎么处理？</h3><ul>
<li>1.人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</li>
<li>2.布局Layout过于复杂，无法在16ms内完成渲染；</li>
<li>3.同一时间动画执行的次数过多，导致CPU或GPU负载过重；</li>
<li>4.View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</li>
<li>5.View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；</li>
<li>6.内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；</li>
<li>7.冗余资源及逻辑等导致加载和执行缓慢；</li>
<li>8.臭名昭著的ANR；</li>
</ul>
<h3 id="mvc、mvp、mvvm"><a href="#mvc、mvp、mvvm" class="headerlink" title="mvc、mvp、mvvm"></a>mvc、mvp、mvvm</h3><p>一、MVC（Model-View-Controller）<br>MVC是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。<br><img src="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104514423-1559724064.png" alt="image"><br>二、MVP（Model-View-Presenter）<br>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。<br><img src="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104605782-274682269.png" alt="image"><br>三、MVVM（Model-View-ViewModel）</p>
<p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p>
<p>这方面典型的应用有.NET的WPF，js框架Knockout、AngularJS等。<br><img src="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104658079-573770286.png" alt="image"></p>
<h3 id="RxJava特点"><a href="#RxJava特点" class="headerlink" title="RxJava特点"></a>RxJava特点</h3><ul>
<li>（1）观察者模式<br>  RxJava用到了设计模式中的观察者模式。支持数据或事件序列，允许对序列进行组合，并对线程、同步和并发数据结构进行了抽象。</li>
<li>（2）轻量<br>  无依赖库、Jar包小于1M</li>
<li>（3）支持多语言<br>  支持Java 6+和Android 2.3+。RxJava设计初衷就是兼容所有JVM语言，目前支持的JVM语言有Groovy,Clojure,JRuby, Kotlin和Scala。</li>
<li>（4）多线程支持<br>  封装了各种并发实现，如threads, pools, event loops, fibers, actors。</li>
</ul>
<h3 id="如何判断对象可以被GC"><a href="#如何判断对象可以被GC" class="headerlink" title="如何判断对象可以被GC"></a>如何判断对象可以被GC</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p>
<h3 id="性能优化有哪些"><a href="#性能优化有哪些" class="headerlink" title="性能优化有哪些"></a>性能优化有哪些</h3><ul>
<li>(1) 降低执行时间<br>又包括几小类<br>a. 利用多线程并发或分布式提高 TPS<br>b. 缓存(包括对象缓存、IO 缓存、网络缓存等)<br>c. 数据结构和算法优化<br>d. 性能更优的底层接口调用，如 JNI 实现<br>e. 逻辑优化<br>f. 需求优化</li>
<li>(2) 同步改异步，利用多线程提高TPS</li>
<li>(3) 提前或延迟操作，错峰提高TPS</li>
</ul>
<h3 id="如何保活"><a href="#如何保活" class="headerlink" title="如何保活"></a>如何保活</h3><ol>
<li>通过轮训的方式查询远端进程的状态</li>
<li>通过发送心跳包来看是否能接受应答,无应答，远端进程可能已经退出</li>
<li>在Application生命周期终止时，也就是onTerminate方法里发送广播通知对方自己即将灭亡</li>
<li>双服务互相监听守护进程</li>
<li>添加到系统白名单</li>
</ol>
<h3 id="Webview问题简述"><a href="#Webview问题简述" class="headerlink" title="Webview问题简述"></a>Webview问题简述</h3><p><a href="http://note.youdao.com/noteshare?id=f19d54be4b90b89079cd9bfbc52bbade&amp;sub=3624218D84CD438FB033603C18D57AE4" target="_blank" rel="noopener">查看详情</a></p>
<h3 id="As编译慢，怎么提速"><a href="#As编译慢，怎么提速" class="headerlink" title="As编译慢，怎么提速"></a>As编译慢，怎么提速</h3><p>首先找到你工程目录下的gradle.properties配置文件，然后打开并在其中添加以下配置：<br>org.gradle.daemon=true</p>
<p>org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</p>
<p>org.gradle.parallel=true</p>
<p>org.gradle.configureondemand=true<br>PS：如果你的工程是从Eclipse工程导入的，工程目录下可能找不到gradle.properties这个文件，这时可在C:\Users\用户\ .gradle文件夹下新建<br>gradle.properties文件并用文本编辑器打开，添加以上配置就可以了。<br><a href="http://www.jianshu.com/p/5eeb8bf92559?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq" target="_blank" rel="noopener">Android Studio加速编译方法汇总</a></p>
<h3 id="String和Stringbuilder区别"><a href="#String和Stringbuilder区别" class="headerlink" title="String和Stringbuilder区别"></a>String和Stringbuilder区别</h3><p>String：字符串常量,如果要操作少量的数据用<br>StringBuilder：字符串变量,单线程操作字符串缓冲区下操作大量数据用</p>
<h3 id="Handler内存泄漏原因"><a href="#Handler内存泄漏原因" class="headerlink" title="Handler内存泄漏原因"></a>Handler内存泄漏原因</h3><p>1.在Java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用，由于Handler是非静态内部类所以其持有当前Activity的隐式引用，如果Handler没有被释放，其所持有的外部引用也就是Activity也不可能被释放，当一个对象一句不需要再使用了，本来该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中这就产生了内存泄漏，最终也就造成了OOM……<br>2.Handler、Message、MessageQueue是相互关联在一起的，Handler通过发送消息Message与主线程进行交互，如果Handler发送的消息Message尚未被处理，该Message及发送它的Handler对象将被MessageQueue一直持有，这样就可能会导致Handler无法被回收。</p>
<h3 id="弱引用、强引用用途"><a href="#弱引用、强引用用途" class="headerlink" title="弱引用、强引用用途"></a>弱引用、强引用用途</h3><p>1．强引用<br>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;</span><br><span class="line">  List&lt;String&gt; list = new Arraylist&lt;String&gt;();</span><br><span class="line">  list.add(str);</span><br><span class="line">  在list集合里的数据不会释放，即使内存不足也不会</span><br></pre></td></tr></table></figure>
<p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object c = new Car(); //只要c还指向car object, car object就不会被回收</span><br><span class="line">WeakReference&lt;Car&gt; weakCar = new WeakReference(Car)(car);</span><br></pre></td></tr></table></figure></p>
<p>当要获得weak reference引用的object时, 首先需要判断它是否已经被回收:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakCar.get();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>强引用：<br>String str = “abc”;<br>list.add(str); </li>
<li>软引用：<br>如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象 </li>
<li>弱引用：<br>如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象 </li>
<li>虚引用：<br>虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s = “abc”;如果没有对象回收了， 就回收没虚引用的对象</li>
</ul>
<h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><p>1.复用重写getView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">		public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">			View view;</span><br><span class="line">			// 判断convertView的状态，来达到复用效果</span><br><span class="line">			if (null == convertView) &#123;</span><br><span class="line">				//如果convertView为空，则表示第一次显示该条目，需要创建一个view</span><br><span class="line">				view = View.inflate(MainActivity.this, R.layout.listview_item,</span><br><span class="line">						null);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				//否则表示可以复用convertView</span><br><span class="line">				view = convertView;</span><br><span class="line">			&#125;</span><br><span class="line">			// listview_item里只有一个textview</span><br><span class="line">			TextView tv_item = (TextView) view.findViewById(R.id.tv_item);</span><br><span class="line">			tv_item.setText(list.get(position));</span><br><span class="line">			return view;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.新建一个内部静态类复用view<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static class ViewHolder &#123;</span><br><span class="line">		private TextView tvHolder;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.分页加载数据</p>
<h3 id="如何提高引用扩展性"><a href="#如何提高引用扩展性" class="headerlink" title="如何提高引用扩展性"></a>如何提高引用扩展性</h3><p>这个~~~我也不清楚</p>
<h3 id="重构准则"><a href="#重构准则" class="headerlink" title="重构准则"></a>重构准则</h3><ul>
<li>添加功能时一并重构；<br>修补错误时一并重构；<br>复审代码时一并重构； </li>
<li>重构可提高软件质量（改善设计、提升可读性、减少错误），良好设计是快速软件开发的根本。</li>
</ul>
<h3 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h3><p>为了避免ANR，我们会通常把 耗时操作放在子线程里面去执行，因为子线程不能更新UI，所以当子线程需要更新的UI的时候就需要借助到安卓的消息机制，也就是Handler机制了</p>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul>
<li>leep是Thread类的静态方法。sleep的作用是让线程休眠制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行</li>
<li><p>wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者</p>
</li>
<li><p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。</p>
</li>
<li><p>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</p>
</li>
<li><p>在调用sleep()方法的过程中，线程不会释放对象锁。</p>
</li>
<li><p>而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备</p>
</li>
</ul>
<p>获取对象锁进入运行状态。</p>
<h3 id="String，StringBuffer，StringBuilder的区别，哪个是线程安全的"><a href="#String，StringBuffer，StringBuilder的区别，哪个是线程安全的" class="headerlink" title="String，StringBuffer，StringBuilder的区别，哪个是线程安全的"></a>String，StringBuffer，StringBuilder的区别，哪个是线程安全的</h3><ul>
<li>String 字符串常量</li>
<li>StringBuffer 字符串变量（线程安全）</li>
<li>StringBuilder 字符串变量（非线程安全）</li>
</ul>
<h3 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h3><ul>
<li>Measure - Layout - Draw<br>measure过程的核心方法: measure() - onMeasure() - setMeasuredDimension().<br>子视图的具体位置都是相对于父视图而言的。View的onLayout()方法为空实现，而ViewGroup的onLayout为abstract，因此，自定义的View要继承ViewGroup时，必须实现onLayout函数。</li>
<li>所有视图最终都是调用View的draw方法进行绘制。 在自定义视图中， 也不应该复写该方法， 而是复写onDraw（）方法进行绘制， 如果自定义的视图确实要复写该方法，先调用super.draw()完成系统的绘制，再进行自定义的绘制。</li>
</ul>
<h3 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h3><ul>
<li>分发事件，默认为false。true：取消事件，不继续向下分发，false：向下分发事件<ul>
<li>拦截事件，默认为false。true：拦截事件，自身的onTouchEvent()方法消费，false：事件继续向下传递</li>
<li>处理事件，默认为false，true：消费事件，false：不消费事件，向上层传递让上层处理。【注】如果发生了拦截，那么如果该层不处理则会继续向上传递，让上层处理。如果过程中没有发生处理，则事件分发到底层后将一直向上层传递至Activity，在Activity的onTouchEvent()中处理。【注】如果在设置了setOnClickListener(…)的View或Viewgroup中，返回true则消费事件，会触发onClick事件，如果返回false，则不会触发onClick事件</li>
</ul>
</li>
</ul>
<h1 id="JAVA-相关"><a href="#JAVA-相关" class="headerlink" title="JAVA 相关"></a>JAVA 相关</h1><p>1.静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用?持有的引用是this?还是其它?</p>
<p>静态内部类：使用static修饰的内部类</p>
<p>内部类：就是在某个类的内部又定义了一个类，内部类所嵌入的类称为外部类</p>
<p>匿名内部类：使用new生成的内部类</p>
<p>因为内部类的产生依赖于外部类，持有的引用是类名.this</p>
<p>2.Java中try catch finally的执行顺序</p>
<p>先执行try中代码，如果发生异常执行catch中代码，最后一定会执行finally中代码</p>
<p>3.equals与==的区别：</p>
<p>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相</p>
<p>4.Object有哪些公用方法?</p>
<p>方法equals测试的是两个对象是否相等</p>
<p>方法clone进行对象拷贝</p>
<p>方法getClass返回和当前对象相关的Class对象</p>
<p>方法notify,notifyall,wait都是用来对给定对象进行线程同步的</p>
<p>5.String、StringBuffer与StringBuilder的区别</p>
<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象 StringBuffer和StringBuilder底层是 char[]数组实现的 StringBuffer是线程安全的，而StringBuilder是线程不安全的</p>
<p>6.Java的四种引用的区别</p>
<p>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</p>
<p>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</p>
<p>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</p>
<p>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</p>
<p>7.介绍垃圾回收机制</p>
<p>标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片</p>
<p>标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率</p>
<p>复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。</p>
<p>分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法</p>
<h1 id="集合、数据结构相关"><a href="#集合、数据结构相关" class="headerlink" title="集合、数据结构相关"></a>集合、数据结构相关</h1><p>1.你用过哪些集合类</p>
<p>数据结构中用于存储数据的有哪些</p>
<p>数组</p>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1);数组的特点是：寻址容易，插入和删除困难;</p>
<p>链表</p>
<p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：寻址困难，插入和删除容易。</p>
<p>2.说说hashMap是怎样实现的</p>
<p>哈希表:由数组+链表组成的</p>
<p>当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置(即下标)，如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>3.ArrayList,LinkedList的区别</p>
<p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p>
<p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p>
<p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p>
<p>4.ArrayList和Vector的主要区别是什么?</p>
<p>ArrayList 和Vector底层是采用数组方式存储数据</p>
<p>Vector:</p>
<p>线程同步</p>
<p>当Vector中的元素超过它的初始大小时，Vector会将它的容量翻倍，</p>
<p>ArrayList:</p>
<p>线程不同步，但性能很好</p>
<p>当ArrayList中的元素超过它的初始大小时，ArrayList只增加50%的大小</p>
<p>5.HashMap和 HashTable 的区别：</p>
<p>HashTable比较老，是基于Dictionary 类实现的，HashTable 则是基于 Map接口实现的</p>
<p>HashTable 是线程安全的， HashMap 则是线程不安全的</p>
<p>HashMap可以让你将空值作为一个表的条目的key或value</p>
<p>算法相关</p>
<p>1.排序算法和稳定性，快排什么时候情况最坏?</p>
<p>2.给最外层的rootview，把这个根视图下的全部button背景设置成红色，手写代码，不许用递归</p>
<p>算法原理：</p>
<p>Android的view视图是按树形结构分布，所以按树形结构遍历</p>
<p>循环判断每一层的ViewGroup元素，将其入栈;否则判断当前view是否是Button类实例，是则改写背景色</p>
<p>当前ViewGroup检查childView完成后，判断栈是否非空，取出栈顶元素ViewGroup重复步骤2直至栈为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void changeAllBtnBGColor(View view, int color) &#123;</span><br><span class="line">if (view == null || !(view instanceof ViewGroup))</span><br><span class="line">return; </span><br><span class="line">Stack m = new Stack&lt;&gt;();</span><br><span class="line">while (view != null) &#123; </span><br><span class="line">ViewGroup tmpGroup = (ViewGroup) view; </span><br><span class="line">int count = tmpGroup.getChildCount(); </span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123; View child = tmpGroup.getChildAt(i);</span><br><span class="line">if (child instanceof ViewGroup) m.add(child); </span><br><span class="line">else if (child instanceof Button) &#123; child.setBackgroundColor(color);</span><br><span class="line">&#125; &#125; </span><br><span class="line">if (m.isEmpty()) break; </span><br><span class="line">else view = m.pop();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Thread、AsynTask相关"><a href="#Thread、AsynTask相关" class="headerlink" title="Thread、AsynTask相关"></a>Thread、AsynTask相关</h1><p>1.wait()和sleep()的区别<br>sleep来自Thread类，和wait来自Object类</p>
<p>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</p>
<p>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</p>
<p>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒</p>
<p>2.若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?</p>
<p>当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常</p>
<p>同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</p>
<p>3.Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决?</p>
<p>还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新</p>
<p>4.Android 线程间通信有哪几种方式(重要)</p>
<p>共享内存(变量);</p>
<p>文件，数据库;</p>
<p>Handler;</p>
<p>Java 里的 wait()，notify()，notifyAll()</p>
<p>5.请介绍下 AsyncTask的内部实现，适用的场景是</p>
<p>AsyncTask 内部也是 Handler 机制来完成的，只不过 Android 提供了执行框架来提供线程池来</p>
<p>执行相应地任务，因为线程池的大小问题，所以 AsyncTask 只应该用来执行耗时时间较短的任务，</p>
<p>比如 HTTP 请求，大规模的下载和数据库的更改不适用于 AsyncTask，因为会导致线程池堵塞，没有</p>
<p>线程来执行其他的任务，导致的情形是会发生 AsyncTask 根本执行不了的问题。</p>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p>1.TCP三次握手</p>
<p>2.为什么TCP是可靠的，UDP早不可靠的?为什么UDP比TCP快?</p>
<p>TCP/IP协议高，因为其拥有三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。</p>
<p>UDP就没有了，udp信息发出后,不验证是否到达对方,所以不可靠。</p>
<p>但是就速度来说，还是UDP协议更高，毕竟其无需重复返回验证，只是一次性的</p>
<p>3.http协议了解多少，说说里面的协议头部有哪些字段?</p>
<p>http(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议;http请求由三部分组成，分别是：请求行、消息报头、请求正文。</p>
<p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头</p>
<p>4.https了解多少</p>
<p>HTTPS(全称：Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>5.谈谈 HTTP 中Get 和 Post 方法的区别</p>
<p>GET - 从指定的服务器中获取数据，明文发送内容</p>
<p>POST - 提交数据给指定的服务器处理</p>
<ol>
<li><p>POST请求不能被缓存下来</p>
</li>
<li><p>POST请求不会保存在浏览器浏览记录中</p>
</li>
<li><p>以POST请求的URL无法保存为浏览器书签</p>
</li>
<li><p>POST请求没有长度限制</p>
</li>
</ol>
<p>6.推送心跳包是TCP包还是UDP包或者HTTP包</p>
<p>心跳包的实现是调用了socket.sendUrgentData(0xFF)这句代码实现的，所以，当然是TCP包。</p>
<p>7.如何实现文件断点上传</p>
<p>在 Android 中上传文件可以采用 HTTP 方式，也可以采用 Socket 方式，但是 HTTP 方式不能上传</p>
<p>大文件，这里介绍一种通过 Socket 方式来进行断点续传的方式，服务端会记录下文件的上传进度，</p>
<p>当某一次上传过程意外终止后，下一次可以继续上传，这里用到的其实还是 J2SE 里的知识。</p>
<p>这个上传程序的原理是：客户端第一次上传时向服务端发送</p>
<p>“Content-Length=35;filename=WinRAR_3.90_SC.exe;sourceid=“这种格式的字符串，服务端</p>
<p>收到后会查找该文件是否有上传记录，如果有就返回已经上传的位置，否则返回新生成的 sourceid</p>
<p>以及 position 为 0，类似 sourceid=2324838389;position=0“这样的字符串，客户端收到返回后</p>
<p>的字符串后再从指定的位置开始上传文件。</p>
<h1 id="Fragment相关"><a href="#Fragment相关" class="headerlink" title="Fragment相关"></a>Fragment相关</h1><p>1.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的?</p>
<p>Fragment 的事物管理器内部维持了一个双向链表结构，该结构可以记录我们每次 add 的</p>
<p>Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮的时候会自动帮我们实现退栈操作。</p>
<p>2.Fragment 在你们项目中的使用</p>
<p>Fragment 是 android3.0 以后引入的的概念，做局部内容更新更方便，原来为了到达这一点要</p>
<p>把多个布局放到一个 activity 里面，现在可以用多 Fragment 来代替，只有在需要的时候才加载</p>
<p>Fragment，提高性能。</p>
<p>Fragment 的好处：</p>
<ol>
<li>Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有它自己的生命周期和</li>
</ol>
<p>UI。</p>
<ol>
<li>Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电</li>
</ol>
<p>脑。</p>
<ol>
<li>Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中动态地移除、加入、</li>
</ol>
<p>交换等。</p>
<ol>
<li><p>Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI。</p>
</li>
<li><p>Fragment 解决 Activity 间的切换不流畅，轻量切换。</p>
</li>
<li><p>Fragment 替代 TabActivity 做导航，性能更好。</p>
</li>
<li><p>Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的界面效果</p>
</li>
</ol>
<p>3.如何切换 fragement,不重新实例化</p>
<p>正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment;再次切换时，只需 hide()当前，</p>
<p>show()另一个</p>
<h1 id="四大组件相关"><a href="#四大组件相关" class="headerlink" title="四大组件相关"></a>四大组件相关</h1><p>1.Activity和Fragment生命周期有哪些?</p>
<p>Activity——onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy</p>
<p>Fragment——onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach</p>
<p>2.广播的两种注册方式及有什么区别</p>
<p>3.内存不足时，怎么保持Activity的一些状态，在哪个方法里面做具体操作?</p>
<p>Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况(如：内存不足、用户直接按Home键)由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。</p>
<p>4.启动service的两种方法?有什么区别?</p>
<p>一种是startService(),另一种是bindService()。这两者的区别是第一种方式调用者开启了服务，即会与服务失去联系，两者没有关联。即使访问者退出了，服务仍在运行。如需解除服务必须显式的调用stopService方法。主要用于调用者与服务没有交互的情况下，也就是调用者不需要获取服务里的业务方法。比如电话录音。而后者调用者与服务绑定在一起的。当调用者退出的时候，服务也随之退出。用于需要与服务交互。</p>
<p>5.Android中的Context, Activity，Appliction有什么区别?</p>
<p>相同：Activity和Application都是Context的子类。</p>
<p>Context从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理上下文环境中各个参数和变量的总用，方便我们可以简单的访问到各种资源。</p>
<p>不同：维护的生命周期不同。 Context维护的是当前的Activity的生命周期，Application维护的是整个项目的生命周期。</p>
<p>使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>
<ol>
<li><p>不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的。</p>
</li>
<li><p>对于生命周期长的对象，可以使用application，context。</p>
</li>
<li><p>避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。</p>
</li>
</ol>
<p>6.Context是什么?</p>
<p>它描述的是一个应用程序环境的信息，即上下文。</p>
<p>该类是一个抽象(abstract class)类，Android提供了该抽象类的具体实现类(ContextIml)。</p>
<p>通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播，接受Intent，信息，等。</p>
<p>7.Service 是否在 main thread 中执行, service 里面是否能执行耗时的操</p>
<p>作?</p>
<p>默认情况,如果没有显示的指 servic 所运行的进程, Service 和 activity 是运行在当前 app 所在进</p>
<p>程的 main thread(UI 主线程)里面。</p>
<p>service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )</p>
<p>特殊情况 ,可以在清单文件配置 service 执行所在的进程 ,让 service 在另外的进程中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service </span><br><span class="line">android:name=&quot;com.baidu.location.f&quot;</span><br><span class="line">android:enabled=&quot;true&quot;</span><br><span class="line">android:process=&quot;:remote&quot; &gt; </span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p>8.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己对应的</p>
<p>Service?</p>
<p>Activity 通过 bindService(Intent service, ServiceConnection conn, int flags)跟 Service 进行</p>
<p>绑定，当绑定成功的时候 Service 会将代理对象通过回调的形式传给 conn，这样我们就拿到了</p>
<p>Service 提供的服务代理对象。</p>
<p>在 Activity 中可以通过 startService 和 bindService 方法启动 Service。一般情况下如果想获取</p>
<p>Service 的服务对象那么肯定需要通过 bindService()方法，比如音乐播放器，第三方支付等。如</p>
<p>果仅仅只是为了开启一个后台任务那么可以使用 startService()方法。</p>
<p>9.说说 Activity、Intent、Service 是什么关系</p>
<p>他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是 Android 四大组件</p>
<p>之一。他俩都是 Context 类的子类 ContextWrapper 的子类，因此他俩可以算是兄弟关系吧。不过</p>
<p>兄弟俩各有各自的本领，Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。Activity</p>
<p>和 Service 之间可以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者。</p>
<p>10.请描述一下 BroadcastReceiver</p>
<p>BroadCastReceiver 是 Android 四大组件之一，主要用于接收系统或者 app 发送的广播事件。</p>
<p>广播分两种：有序广播和无序广播。</p>
<p>内部通信实现机制：通过 Android 系统的 Binder 机制实现通信。</p>
<ol>
<li>无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不</li>
</ol>
<p>能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。</p>
<ol>
<li>有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者 A，B，C，</li>
</ol>
<p>优先级是 A &gt; B &gt; C。那这个消息先传给 A，再传给 B，最后传给 C。每个接收者有权终止广播，比</p>
<p>如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，</p>
<p>B 可以从结果对象中取得 A 存入的数据。</p>
<p>在通过 Context.sendOrderedBroadcast(intent, receiverPermission, resultReceiver, scheduler,</p>
<p>initialCode, initialData, initialExtras)时我们可以指定 resultReceiver 广播接收者，这个接收者我们</p>
<p>可以认为是最终接收者，通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的</p>
<p>onReceive 会被执行两次，第一次是正常的按照优先级顺序执行，第二次是作为最终接收者接收。</p>
<p>如果比他优先级高的接收者终止了广播，那么他依然能接收到广播</p>
<p>11.为什么要用 ContentProvider?它和 sql 的实现上有什么差别?</p>
<p>ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的</p>
<p>uri 就可以了，ContentProvider 可以实现不同 app 之间共享。</p>
<p>Sql 也有增删改查的方法，但是 sql 只能查询本应用下的数据库。而 ContentProvider 还可</p>
<p>以去增删改查本地文件. xml 文件的读取等。</p>
<p>12.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系</p>
<p>a. ContentProvider 内容提供者，用于对外提供数据</p>
<p>b. ContentResolver.notifyChange(uri)发出消息</p>
<p>c. ContentResolver 内容解析者，用于获取内容提供者提供的数据</p>
<p>d. ContentObserver 内容监听器，可以监听数据的改变状态</p>
<p>e. ContentResolver.registerContentObserver()监听消息。</p>
<h1 id="View-相关"><a href="#View-相关" class="headerlink" title="View 相关"></a>View 相关</h1><p>1.onInterceptTouchEvent()和onTouchEvent()的区别</p>
<p>onInterceptTouchEvent()用于拦截触摸事件</p>
<p>onTouchEvent()用于处理触摸事件</p>
<p>2.RemoteView在哪些功能中使用</p>
<p>APPwidget和Notification中</p>
<ol>
<li>SurfaceView和View的区别是什么?</li>
</ol>
<p>SurfaceView中采用了双缓存技术，在单独的线程中更新界面</p>
<p>View在UI线程中更新界面</p>
<p>4.View的绘制过程</p>
<p>一个View要显示在界面上，需要经历一个View树的遍历过程，这个过程又可以分为三个过程，也就是自定义View中的三要素：大小，位置，画什么，即onMesure()，onLayout(),onDraw()。</p>
<p>1.onMesure()确定一个View的大小;</p>
<p>2.onLayout()确定View在父节点上的位置;</p>
<p>3.onDraw()绘制View 的内容;</p>
<p>5.如何自定义ViewGroup</p>
<p>1.指定的LayoutParams</p>
<p>2.onMeasure中计算所有childView的宽和高，然后根据childView的宽和高，计算自己的宽和高。(当然，如果不是wrap_content，直接使用父ViewGroup传入的计算值即可)</p>
<p>3.onLayout中对所有的childView进行布局。</p>
<p>6.View中onTouch，onTouchEvent，onClick的执行顺序</p>
<p>dispatchTouchEvent—-&gt;onTouch—-&gt;onTouchEvent—–&gt;onClick。在所有ACTION_UP事件之后才触发onClick点击事件。</p>
<h1 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h1><p>1.ListView卡顿的原因与性能优化，越多越好</p>
<p>重用converView： 通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</p>
<p>减少findViewById()操作： 将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</p>
<p>避免在 getView 方法中做耗时的操作: 例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</p>
<p>Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</p>
<p>尽量能保证 Adapter 的 hasStableIds() 返回 true 这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的</p>
<p>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。 由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现</p>
<p>使用 RecycleView 代替listview： 每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</p>
<p>ListView 中元素避免半透明： 半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。 在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</p>
<p>尽量开启硬件加速： 硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</p>
<p>2.如何避免 OOM 问题的出现</p>
<p>使用更加轻量的数据结构 例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效，在于他们避免了对key与value的自动装箱(autoboxing)，并且避免了装箱后的解箱。</p>
<p>避免在Android里面使用Enum Android官方培训课程提到过“Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.”，具体原理请参考《Android性能优化典范(三)》，所以请避免在Android里面使用到枚举。</p>
<p>减小Bitmap对象的内存占用 Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用可谓是重中之重，，通常来说有以下2个措施： ++inSampleSize++：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 ++decode format++：解码格式，选择ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异</p>
<p>Bitmap对象的复用 缩小Bitmap的同时，也需要提高BitMap对象的复用率，避免频繁创建BitMap对象，复用的方法有以下2个措施 LRUCache : “最近最少使用算法”在Android中有极其普遍的应用。ListView与GridView等显示大量图片的控件里，就是使用LRU的机制来缓存处理好的Bitmap，把近期最少使用的数据从缓存中移除，保留使用最频繁的数据， inBitMap高级特性:利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小</p>
<p>使用更小的图片 在涉及给到资源图片时，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用更小的图片。尽量使用更小的图片不仅可以减少内存的使用，还能避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图时会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>
<p>StringBuilder 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>
<p>避免在onDraw方法里面执行对象的创建 类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>
<p>避免对象的内存泄露</p>
<p>3.三级缓存的原理</p>
<p>从缓存中加载。</p>
<p>从本地文件中加载(数据库，SD)</p>
<p>从网络加载。</p>
<p>a.加载 bitmap 的时候无需考虑 bitmap 加载过程中出现的 oom(内存溢出)和 android 容器快速</p>
<p>滑动的时候出现的图片错位等现象。(16M)</p>
<p>b. 支持加载网络图片和本地图片。</p>
<p>c. 内存管理使用的 lru 算法(移除里面是有频率最少的对象)，更好的管理 bitmap 的内存</p>
<h1 id="Android其他"><a href="#Android其他" class="headerlink" title="Android其他"></a>Android其他</h1><p>1.讲一下android中进程的优先级?</p>
<p>前台进程</p>
<p>可见进程</p>
<p>服务进程</p>
<p>后台进程</p>
<p>空进程</p>
<p>2.介绍Handle的机制</p>
<p>Handler通过调用sendmessage方法把消息放在消息队列MessageQueue中，Looper负责把消息从消息队列中取出来，重新再交给Handler进行处理，三者形成一个循环</p>
<p>通过构建一个消息队列，把所有的Message进行统一的管理，当Message不用了，并不作为垃圾回收，而是放入消息队列中，供下次handler创建消息时候使用，提高了消息对象的复用，减少系统垃圾回收的次数</p>
<p>每一个线程，都会单独对应的一个looper，这个looper通过ThreadLocal来创建，保证每个线程只创建一个looper，looper初始化后就会调用looper.loop创建一个MessageQueue，这个方法在UI线程初始化的时候就会完成，我们不需要手动创建</p>
<p>3.Dalvik虚拟机与JVM有什么区别</p>
<p>Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。</p>
<p>Dalvik执行.dex格式的字节码，而JVM执行.class格式的字节码。</p>
<p>4.每个应用程序对应多少个Dalvik虚拟机</p>
<p>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行 ，而所有的Android应用的线程都对应一个Linux线程</p>
<p>5.应用常驻后台，避免被第三方杀掉的方法</p>
<p>Service设置成START_STICKY kill 后会被重启(等待5秒左右)，重传Intent，保持与重启前一样</p>
<p>通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill</p>
<p>双进程Service： 让2个进程互相保护对方，其中一个Service被清理后，另外没被清理的进程可以立即重启进程</p>
<p>用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响(Android5.0以上的版本不可行</p>
<p>联系厂商，加入白名单</p>
<p>6.根据自己的理解描述下Android数字签名。</p>
<p>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序</p>
<p>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证</p>
<p>如果要正式发布一个Android程序，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。</p>
<p>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</p>
<p>7.Dalvik基于JVM的改进</p>
<p>几个class变为一个dex，constant pool，省内存</p>
<p>Zygote，copy-on-write shared,省内存，省cpu，省电</p>
<p>基于寄存器的bytecode，省指令，省cpu，省电</p>
<p>Trace-based JIT,省cpu，省电,省内存</p>
<p>8.ARGB_8888占用内存大小</p>
<p>本题的答案，是4byte，即ARGB各占用8个比特来描述。</p>
<p>9.apk安装卸载的原理</p>
<p>安装过程：复制apk安装包到data/app目录下，解压并扫描安装包，把dex文件(dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录。</p>
<p>卸载过程：删除安装过程中在上述三个目录下创建的文件及目录。</p>
<p>10.通过Intent传递一些二进制数据的方法有哪些?</p>
<p>使用Serializable接口实现序列化，这是Java常用的方法。</p>
<p>实现Parcelable接口，这里Android的部分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见的。</p>
<p>11.横竖屏切换时Activity的生命周期</p>
<p>此时的生命周期跟清单文件里的配置有关系。</p>
<p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期默认首先销毁当前activity,然后重新加载。</p>
<p>设置Activity android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
<p>12.Serializable 和 Parcelable 的区别</p>
<p>在使用内存的时候，Parcelable 类比 Serializable 性能高，所以推荐使用 Parcelable 类。</p>
<ol>
<li><p>Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。</p>
</li>
<li><p>Parcelable 不能使用在要将数据存储在磁盘上的情况。尽管 Serializable 效率低点，但在这</p>
</li>
</ol>
<p>种情况下，还是建议你用 Serializable 。</p>
<p>13.Android 中如何捕获未捕获的异常</p>
<p>自 定 义 一 个 Application ， 比 如 叫 MyApplication 继 承 Application 实 现</p>
<p>UncaughtExceptionHandler。</p>
<p>覆写 UncaughtExceptionHandler 的 onCreate 和 uncaughtException 方法。</p>
<p>14.Android 的权限规则</p>
<p>Android 中的 apk 必须签名</p>
<p>基于 UserID 的进程级别的安全机制</p>
<p>默认 apk 生成的数据对外是不可见的</p>
<p>AndroidManifest.xml 中的显式权限声明</p>
<p>15.多线程间通信和多进程之间通信有什么不同，分别怎么实现?</p>
<p>一、进程间的通信方式</p>
<ol>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的</li>
</ol>
<p>进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<ol>
<li>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的</li>
</ol>
<p>通信。</p>
<ol>
<li>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它</li>
</ol>
<p>常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进</p>
<p>程间以及同一进程内不同线程之间的同步手段。</p>
<ol>
<li>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符</li>
</ol>
<p>标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<ol>
<li><p>信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内</p>
</li>
</ol>
<p>存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间</p>
<p>通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间</p>
<p>的同步和通信。</p>
<ol>
<li>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同</li>
</ol>
<p>及其间的进程通信。</p>
<p>二、线程间的通信方式</p>
<ol>
<li>锁机制：包括互斥锁、条件变量、读写锁</li>
</ol>
<p>*互斥锁提供了以排他方式防止数据结构被并发修改的方法。</p>
<p>*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</p>
<p>*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁</p>
<p>的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<ol>
<li><p>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</p>
</li>
<li><p>信号机制(Signal)：类似进程间的信号处理</p>
</li>
</ol>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机</p>
<p>制。</p>
<p>16.说说 LruCache 底层原理</p>
<p>LruCache 使用一个 LinkedHashMap 简单的实现内存的缓存，没有软引用，都是强引用。如果添</p>
<p>加的数据大于设置的最大值，就删除最先缓存的数据来调整内存。</p>
<p>maxSize 是通过构造方法初始化的值，他表示这个缓存能缓存的最大值是多少。</p>
<p>size 在添加和移除缓存都被更新值，他通过 safeSizeOf 这个方法更新值。safeSizeOf 默认返回 1，</p>
<p>但一般我们会根据 maxSize 重写这个方法，比如认为 maxSize 代表是 KB 的话，那么就以 KB 为单</p>
<p>位返回该项所占的内存大小。</p>
<p>除异常外首先会判断 size 是否超过 maxSize，如果超过了就取出最先插入的缓存，如果不为空就</p>
<p>删掉，并把 size 减去该项所占的大小。这个操作将一直循环下去，直到 size 比 maxSize 小或者缓存</p>
<p>为空。</p>
<h2 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h2><p>AndroidFire，一款新闻阅读 App框架，基于 Material Design + MVP + RxJava + Retrofit + Glide，<br>基本涵盖了当前 Android 端开发最常用的主流框架，基于此框架可以快速开发一个app。</p>
<h2 id="GitHub-源码"><a href="#GitHub-源码" class="headerlink" title="GitHub 源码"></a><a href="https://github.com/jaydenxiao2016/AndroidFire" target="_blank" rel="noopener">GitHub 源码</a></h2>]]></content>
      
        
        <tags>
            
            <tag> android 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>/2017/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。<br>这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。<br>《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述。<br><a id="more"></a></p>
<h3 id="创建范例"><a href="#创建范例" class="headerlink" title="创建范例"></a>创建范例</h3><p>创建范例全部是关于如何创建实例的。这组范例可以被划分为两组：<br>类创建范例及对象创建范例。类创建实例在实例化过程中有效的使用类之间的继承关系，<br>对象创建范例则使用代理来完成其任务。包括：</p>
<ul>
<li>抽象工厂（Abstact Factory）</li>
<li>构造器(Builder Pattern)</li>
<li>工厂方法(Factory Method pattern)</li>
<li>原型(Prototype pattern)</li>
<li>单例模式(Singleton pattern)</li>
</ul>
<h3 id="结构范例"><a href="#结构范例" class="headerlink" title="结构范例"></a>结构范例</h3><p>这组范例都是关于对象之间如何通讯的。包括：</p>
<ul>
<li>职责链(Chain-of-responsibility pattern)</li>
<li>命令(Command pattern)</li>
<li>翻译器(Interpreter pattern)</li>
<li>迭代器(Iterator pattern)</li>
<li>仲裁器(Mediator pattern)</li>
<li>回忆(Memento pattern)</li>
<li>观察者(Observer pattern)</li>
<li>状态机(State pattern)</li>
<li>策略(Strategy pattern)</li>
<li>模板方法(Template method pattern)</li>
<li>参观者(Visitor)</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>什么是单例模式？确保一个类只有一个实例，并提供对该实例的全局访问，其构造函数私有化。</p>
<h2 id="七种实现方式"><a href="#七种实现方式" class="headerlink" title="七种实现方式"></a>七种实现方式</h2><p>各种写法各有利弊，让我们看看具体写法：</p>
<h3 id="懒汉模式，线程不安全"><a href="#懒汉模式，线程不安全" class="headerlink" title="懒汉模式，线程不安全"></a>懒汉模式，线程不安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPattern &#123;</span><br><span class="line">   </span><br><span class="line">    private static SingletonPattern singletonPattern = null;</span><br><span class="line">    private SingletonPattern() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonPattern getInstance() &#123;</span><br><span class="line">        if (singletonPattern == null) &#123;</span><br><span class="line">            singletonPattern = new SingletonPattern();</span><br><span class="line">        &#125;</span><br><span class="line">        return singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类加载时只是申明实例，并未实例化，当调用getInstance方法，才进行实例化，<br>但线程不安全，多个线程并发调用getInstance方法可能会导致创建多份相同的单例出来，<br>解决的办法就是使用synchronized关键字。</p>
<h3 id="懒汉模式，线程安全"><a href="#懒汉模式，线程安全" class="headerlink" title="懒汉模式，线程安全"></a>懒汉模式，线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPattern &#123;</span><br><span class="line">    private static SingletonPattern singletonPattern = null;</span><br><span class="line">    public static SingletonPattern getInstance() &#123;</span><br><span class="line">        synchronized (SingletonPattern.class) &#123;</span><br><span class="line">            if (singletonPattern == null)</span><br><span class="line">                singletonPattern = new SingletonPattern();</span><br><span class="line">        &#125;</span><br><span class="line">        return singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized保证一个时间内只能有一个线程得到执行，<br>另一个线程必须等待当前线程执行完才能执行，使得线程安全。<br>缺点每次调用getInstance方法都进行同步，造成了不必要的同步开销。</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPattern &#123;</span><br><span class="line">    //饿汉模式</span><br><span class="line">    private static final SingletonPattern singletonPattern = new SingletonPattern();</span><br><span class="line">    private SingletonPattern() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonPattern getInstance() &#123;</span><br><span class="line">        return singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类加载时就已经进行实例化，类加载较慢，但获取对象速度快，线程安全。</p>
<h3 id="双重校验DCL模式"><a href="#双重校验DCL模式" class="headerlink" title="双重校验DCL模式"></a>双重校验DCL模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPattern &#123;</span><br><span class="line">    private static volatile SingletonPattern singletonPattern = null;</span><br><span class="line">    private SingletonPattern() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonPattern getInstance() &#123;</span><br><span class="line">        //第一层校验，为了避免不必要的同步</span><br><span class="line">        if (singletonPattern == null) &#123;</span><br><span class="line">            synchronized (SingletonPattern.class) &#123;</span><br><span class="line">                //第二层校验，实例null的情况下才创建</span><br><span class="line">                if (singletonPattern == null)</span><br><span class="line">                    singletonPattern = new SingletonPattern();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了volatile关键字，因为多个线程并发时初始化成员变量和对象实例化顺序可能会被打乱，<br>这样就出错了，volatile可以禁止指令重排序。双重校验虽然在一定程度解决了资源的消耗和多余的同步，<br>线程安全问题，但在某些情况还是会出现双重校验失效问题，即DCL失效。</p>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPattern &#123;</span><br><span class="line">    private SingletonPattern() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SingletonPatternHolder &#123;</span><br><span class="line">        private static final SingletonPattern singletonPattern = new SingletonPattern();</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonPattern getInstance() &#123;</span><br><span class="line">        return SingletonPatternHolder.singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次调用getInstance方法时加载SingletonPatternHolder 并初始化singletonPattern，<br>这样不仅能确保线程安全，也能保证SingletonPattern类的唯一性。</p>
<h3 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h3><p>SingletonManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123;</span><br><span class="line">    private SingletonManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private static Map&lt;String, Object&gt; instanceMap = new HashMap&lt;&gt;();</span><br><span class="line">    public static void registerInstance(String key, Object instance) &#123;</span><br><span class="line">        if (!instanceMap.containsKey(key)) &#123;</span><br><span class="line">            instanceMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Object getInstance(String key) &#123;</span><br><span class="line">        return instanceMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingletonPattern</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonPattern &#123;</span><br><span class="line">    SingletonPattern() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        Log.d(&quot;wxl&quot;, &quot;doSomeing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SingletonManager.registerInstance(&quot;SingletonPattern&quot;, new SingletonPattern());</span><br><span class="line">SingletonPattern singletonPattern = (SingletonPattern) SingletonManager.getInstance(&quot;SingletonPattern&quot;);</span><br><span class="line">singletonPattern.doSomething();</span><br></pre></td></tr></table></figure></p>
<p>根据key获取对象对应类型的对象，隐藏了具体实现，降低了耦合度。</p>
<h3 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a>枚举单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        Log.d(&quot;wxl&quot;, &quot;SingletonEnum doSomeing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SingletonEnum.INSTANCE.doSomething();</span><br></pre></td></tr></table></figure></p>
<p>更加简洁，线程安全，还能防止反序列化导致重新创建新的对象，<br>而以上方法还需提供readResolve方法，防止反序列化一个序列化的实例时，会创建一个新的实例。<br>枚举单例模式，我们可能使用的不是很多，但《Effective Java》一书推荐此方法，<br>说“单元素的枚举类型已经成为实现Singleton的最佳方法”。不过Android使用enum之后的dex大小增加很多，<br>运行时还会产生额外的内存占用，因此官方强烈建议不要在Android程序里面使用到enum，枚举单例缺点也很明显。</p>
<h2 id="Android-应用"><a href="#Android-应用" class="headerlink" title="Android 应用"></a>Android 应用</h2><p>AccessibilityManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class AccessibilityManager &#123;</span><br><span class="line">    static final Object sInstanceSync = new Object();</span><br><span class="line">    private static android.view.accessibility.AccessibilityManager sInstance;</span><br><span class="line">    public static AccessibilityManager getInstance(Context context) &#123;</span><br><span class="line">        synchronized (sInstanceSync) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">                //省略部分代码</span><br><span class="line">                sInstance = new AccessibilityManager(context, null, userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputMethodManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class InputMethodManager &#123;</span><br><span class="line">    static android.view.inputmethod.InputMethodManager sInstance;</span><br><span class="line">    public static InputMethodManager getInstance() &#123;</span><br><span class="line">        synchronized (InputMethodManager.class) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">                //省略部分代码</span><br><span class="line">                sInstance = new InputMethodManager(service, Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            return sInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-设计模式</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">维基百科-设计模式：可复用面向对象软件的基础</a></li>
<li>Effective Java</li>
<li><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">设计模式（二）单例模式的七种写法</a></li>
<li><a href="https://blog.csdn.net/happy_horse/article/details/51164262" target="_blank" rel="noopener">Android设计模式之单例模式的七种写法</a></li>
</ul>]]></content>
      
        
        <tags>
            
            <tag> Singleton </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[可视化正则表达式整理]]></title>
      <url>/2016/06/15/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>整理一些常见的正则表达式（附可视化链接）<br><img src="http://appzy.vip/images/sfzhm.png" alt="image"><br><a id="more"></a></p>
<p>数字相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final String P_N_1 = &quot;^[0-9]*$&quot;;// 数字</span><br><span class="line">public static final String P_N_2 = &quot;^\\d&#123;3&#125;$&quot;;// 3为数字</span><br><span class="line">public static final String P_N_3 = &quot;^\\d&#123;3,&#125;$&quot;;// 至少3位数字</span><br><span class="line">public static final String P_N_4 = &quot;^\\d&#123;3,5&#125;$&quot;;// M之N位数字</span><br><span class="line">public static final String P_N_6 = &quot;^-?[1-9]\\d*$&quot;;// 整数</span><br><span class="line">public static final String P_N_7 = &quot;^[1-9]\\d*$&quot;;// 正整数</span><br><span class="line">public static final String P_N_8 = &quot;^-[1-9]\\d*$&quot;;// 负整数</span><br></pre></td></tr></table></figure>
<p>字符串相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static final String P_S_0 = &quot;[\\u4e00-\\u9fa5]&quot;;// 中文</span><br><span class="line">public static final String P_S_1 = &quot;^.&#123;3,20&#125;$&quot;;// 长度为M至N的所有字符</span><br><span class="line">public static final String P_S_2 = &quot;^[A-Za-z]+$&quot;;// 纯英文字母</span><br><span class="line">public static final String P_S_3 = &quot;^[A-Z]+$&quot;;// 纯大写英文字母</span><br><span class="line">public static final String P_S_4 = &quot;^[a-z]+$&quot;;// 纯小写英文字母</span><br><span class="line">public static final String P_S_5 = &quot;^[A-Za-z0-9]+$&quot;;// 数字和英文字母</span><br><span class="line">public static final String P_S_6 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&quot;;// 中文、英文、数字或下划线</span><br><span class="line">public static final String P_S_7 = &quot;^\\\\w+$&quot;;// 中文、英文、数字或下划线</span><br><span class="line">public static final String P_S_8 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$&quot;;// 中文、英文、数字[不包括下划线]</span><br><span class="line">public static final String P_S_9 = &quot;^(f|ht)&#123;1&#125;(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?&quot;;// 赛选字符串中的URL</span><br></pre></td></tr></table></figure>
<p>密码相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static final String P_P_0 = &quot;^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot;;// 密码强度</span><br><span class="line">public static final String P_P_1 = &quot;^[A-Za-z0-9]+$&quot;;// 英文&amp;数字</span><br><span class="line">public static final String P_P_2 = &quot;^[A-Za-z0-9]&#123;4,40&#125;$&quot;;// 英文&amp;数字</span><br><span class="line">public static final String P_P_3 = &quot;^\\w+$ 或 ^\\w&#123;3,20&#125;$&quot;;// 数字、英文字母或下划线</span><br><span class="line">public static final String P_P_4 = &quot;^[a-zA-Z]\\w&#123;5,17&#125;$&quot;;// 密码【以字母开头，长度在6~18之间，只能包含字母、数字和下划线】</span><br><span class="line">public static final String P_P_5 = &quot;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot;;// 强密码【必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间】</span><br></pre></td></tr></table></figure>
<p>时间相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final String P_T_0 = &quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;&quot;;// 日期格式</span><br><span class="line">public static final String P_T_1 =</span><br><span class="line">        &quot;^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$\n&quot;;//校验日期 【“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。】</span><br></pre></td></tr></table></figure>
<p>其他</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final String P_O_1  = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;;// Email</span><br><span class="line">public static final String P_O_2  = &quot;[\\\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\\\.[\\\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])?&quot;;// Email</span><br><span class="line">public static final String P_O_3  = &quot;[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?&quot;;// 域名</span><br><span class="line">public static final String P_O_4  = &quot;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$&quot;;// 手机号码</span><br><span class="line">public static final String P_O_5  = &quot;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d&#123;8&#125;$&quot;;// 手机号码</span><br><span class="line">public static final String P_O_6  = &quot;^\\d&#123;15&#125;|\\d&#123;18&#125;$&quot;;// 身份证号</span><br><span class="line">public static final String P_O_7  = &quot;^[1-9]\\\\d&#123;7&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d&#123;3&#125;$&quot;;// 15位身份证号</span><br><span class="line">public static final String P_O_8  = &quot;^[1-9]\\\\d&#123;5&#125;[1-9]\\\\d&#123;3&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d&#123;3&#125;([0-9]|X)$&quot;;// 18位身份证号</span><br><span class="line">public static final String P_0_9  = &quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;;// 金额校验，精确到2位小数</span><br><span class="line">public static final String P_0_10 = &quot;\\\\&lt; *[img][^=XXFN&#125;*[src] *= *[\\\\\&quot;\\\\&apos;]&#123;0,1&#125;(&#123;FNXX=]*)&quot;;// 获取网页中的图片信息</span><br><span class="line">public static final String P_0_11 = &quot;[1-9][0-9]\\&#123;4,\\&#125;&quot;;// QQ号</span><br></pre></td></tr></table></figure>
<p>判断是否匹配正则<br>判定规则<br>待判定字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isMatch(String regex, CharSequence str) &#123;</span><br><span class="line">    return str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; Pattern.matches(regex, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后奉上：（<a href="https://jex.im/regulex/#!embed=false&amp;flags=&amp;re=" target="_blank" rel="noopener">可视化正则链接</a>)</p>]]></content>
      
        
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
