<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="appzy">
<meta name="baidu-site-verification" content="s8Pe1TBqyy">



<meta name="description" content="整理一些常见的Android面试题（针对于2~3年开发经验中所遇到的问题）">
<meta name="keywords" content="android 面试">
<meta property="og:type" content="article">
<meta property="og:title" content="Android面试总结(问答篇)">
<meta property="og:url" content="http://appzy.vip/2017/03/15/Android面试总结(问答)/index.html">
<meta property="og:site_name" content="appzy">
<meta property="og:description" content="整理一些常见的Android面试题（针对于2~3年开发经验中所遇到的问题）">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104514423-1559724064.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104605782-274682269.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104658079-573770286.png">
<meta property="og:updated_time" content="2017-03-15T14:55:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android面试总结(问答篇)">
<meta name="twitter:description" content="整理一些常见的Android面试题（针对于2~3年开发经验中所遇到的问题）">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104514423-1559724064.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="appzy" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Android面试总结(问答篇) | appzy</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





  <style type="text/css">
  .div_right_bottom {
  width: 200px;
  top: 50%;
  right: 0px;
  position: fixed;
  margin-top: -100px;
  _position: absolute;
}
</style>
</head></html>
<body>
<div class="div_right_bottom" style="z-index:99" align="center">
  <img src="http://appzy.vip/images/csyl.jpg" height="180px" width="180px">
  微信公众号
  </div>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">appzy</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不为模糊不清的未来担忧，只为清清楚楚的现在努力。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false">
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/appzy" title="GitHub"></a>
                            
                                <a class="fa Coding" href="https://coding.net/u/appzy/project" title="Coding"></a>
                            
                                <a class="fa 简书" href="http://www.jianshu.com/users/b2d0a8ba449b/timeline" title="简书"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/le-hu-95-55/activities" title="知乎"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" href="mailto:http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/login.php" title="新浪微博"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidPay/">AndroidPay</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide/">Glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-面试/">android 面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory/">memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webview/">webview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码混淆/">代码混淆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设备信息/">设备信息</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://appzy.vip">appzy</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://appzy.github.io/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Make progress every day and Never give up......</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">appzy</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">appzy</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不为模糊不清的未来担忧，只为清清楚楚的现在努力。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/appzy" title="GitHub"></a>
                            
                                <a class="fa Coding" target="_blank" href="https://coding.net/u/appzy/project" title="Coding"></a>
                            
                                <a class="fa 简书" target="_blank" href="http://www.jianshu.com/users/b2d0a8ba449b/timeline" title="简书"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/le-hu-95-55/activities" title="知乎"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/login.php" title="新浪微博"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap"><article id="post-Android面试总结(问答)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/15/Android面试总结(问答)/" class="article-date">
      <time datetime="2017-03-15T14:55:00.000Z" itemprop="datePublished">2017-03-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        <h1 class="article-title" itemprop="name">
      Android面试总结(问答篇)
    </h1>
      </header>
      
      <div class="article-info article-info-post">
        
        <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android-面试/">android 面试</a></li></ul>
    </div>
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>整理一些常见的Android面试题（针对于2~3年开发经验中所遇到的问题）<br><a id="more"></a></p>
<h3 id="synchronized锁静态方法和非静态方法的区别"><a href="#synchronized锁静态方法和非静态方法的区别" class="headerlink" title="synchronized锁静态方法和非静态方法的区别"></a>synchronized锁静态方法和非静态方法的区别</h3><ul>
<li>非静态方法:<br>给对象加锁(可以理解为给这个对象的内存上锁,注意 只是这块内存,其他同类对象都会有各自的内存锁),这时候<br>在其他一个以上线程中执行该对象的这个同步方法(注意:是该对象)就会产生互斥 <ul>
<li>静态方法:<br>相当于在类上加锁(*.class 位于代码区,静态方法位于静态区域,这个类产生的对象公用这个静态方法,所以这块<br>内存，N个对象来竞争), 这时候,只要是这个类产生的对象,在调用这个静态方法时都会产生互斥 </li>
</ul>
</li>
</ul>
<h3 id="int-和Integer的区别"><a href="#int-和Integer的区别" class="headerlink" title="int 和Integer的区别"></a>int 和Integer的区别</h3><p>1、Integer是int提供的封装类，而int是Java的基本数据类型；</p>
<p>2、Integer默认值是null，而int默认值是0；</p>
<p>3、声明为Integer的变量需要实例化，而声明为int的变量不需要实例化；</p>
<p>4、Integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数值。</p>
<h3 id="内存泄漏有哪些？原因？"><a href="#内存泄漏有哪些？原因？" class="headerlink" title="内存泄漏有哪些？原因？"></a>内存泄漏有哪些？原因？</h3><ul>
<li>1.资源对象没关闭造成的内存泄漏</li>
<li>2.构造Adapter时，没有使用缓存的convertView</li>
<li>3.Bitmap对象不在使用时调用recycle()释放内存</li>
<li>4.试着使用关于application的context来替代和activity相关的context</li>
<li>5.注册没取消造成的内存泄漏</li>
<li>6.集合中对象没清理造成的内存泄漏</li>
</ul>
<h3 id="卡顿的根本原因？怎么处理？"><a href="#卡顿的根本原因？怎么处理？" class="headerlink" title="卡顿的根本原因？怎么处理？"></a>卡顿的根本原因？怎么处理？</h3><ul>
<li>1.人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</li>
<li>2.布局Layout过于复杂，无法在16ms内完成渲染；</li>
<li>3.同一时间动画执行的次数过多，导致CPU或GPU负载过重；</li>
<li>4.View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</li>
<li>5.View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；</li>
<li>6.内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；</li>
<li>7.冗余资源及逻辑等导致加载和执行缓慢；</li>
<li>8.臭名昭著的ANR；</li>
</ul>
<h3 id="mvc、mvp、mvvm"><a href="#mvc、mvp、mvvm" class="headerlink" title="mvc、mvp、mvvm"></a>mvc、mvp、mvvm</h3><p>一、MVC（Model-View-Controller）<br>MVC是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。<br><img src="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104514423-1559724064.png" alt="image"><br>二、MVP（Model-View-Presenter）<br>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。<br><img src="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104605782-274682269.png" alt="image"><br>三、MVVM（Model-View-ViewModel）</p>
<p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p>
<p>这方面典型的应用有.NET的WPF，js框架Knockout、AngularJS等。<br><img src="http://images2015.cnblogs.com/blog/799766/201702/799766-20170227104658079-573770286.png" alt="image"></p>
<h3 id="RxJava特点"><a href="#RxJava特点" class="headerlink" title="RxJava特点"></a>RxJava特点</h3><ul>
<li>（1）观察者模式<br>  RxJava用到了设计模式中的观察者模式。支持数据或事件序列，允许对序列进行组合，并对线程、同步和并发数据结构进行了抽象。</li>
<li>（2）轻量<br>  无依赖库、Jar包小于1M</li>
<li>（3）支持多语言<br>  支持Java 6+和Android 2.3+。RxJava设计初衷就是兼容所有JVM语言，目前支持的JVM语言有Groovy,Clojure,JRuby, Kotlin和Scala。</li>
<li>（4）多线程支持<br>  封装了各种并发实现，如threads, pools, event loops, fibers, actors。</li>
</ul>
<h3 id="如何判断对象可以被GC"><a href="#如何判断对象可以被GC" class="headerlink" title="如何判断对象可以被GC"></a>如何判断对象可以被GC</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p>
<h3 id="性能优化有哪些"><a href="#性能优化有哪些" class="headerlink" title="性能优化有哪些"></a>性能优化有哪些</h3><ul>
<li>(1) 降低执行时间<br>又包括几小类<br>a. 利用多线程并发或分布式提高 TPS<br>b. 缓存(包括对象缓存、IO 缓存、网络缓存等)<br>c. 数据结构和算法优化<br>d. 性能更优的底层接口调用，如 JNI 实现<br>e. 逻辑优化<br>f. 需求优化</li>
<li>(2) 同步改异步，利用多线程提高TPS</li>
<li>(3) 提前或延迟操作，错峰提高TPS</li>
</ul>
<h3 id="如何保活"><a href="#如何保活" class="headerlink" title="如何保活"></a>如何保活</h3><ol>
<li>通过轮训的方式查询远端进程的状态</li>
<li>通过发送心跳包来看是否能接受应答,无应答，远端进程可能已经退出</li>
<li>在Application生命周期终止时，也就是onTerminate方法里发送广播通知对方自己即将灭亡</li>
<li>双服务互相监听守护进程</li>
<li>添加到系统白名单</li>
</ol>
<h3 id="Webview问题简述"><a href="#Webview问题简述" class="headerlink" title="Webview问题简述"></a>Webview问题简述</h3><p><a href="http://note.youdao.com/noteshare?id=f19d54be4b90b89079cd9bfbc52bbade&amp;sub=3624218D84CD438FB033603C18D57AE4" target="_blank" rel="noopener">查看详情</a></p>
<h3 id="As编译慢，怎么提速"><a href="#As编译慢，怎么提速" class="headerlink" title="As编译慢，怎么提速"></a>As编译慢，怎么提速</h3><p>首先找到你工程目录下的gradle.properties配置文件，然后打开并在其中添加以下配置：<br>org.gradle.daemon=true</p>
<p>org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</p>
<p>org.gradle.parallel=true</p>
<p>org.gradle.configureondemand=true<br>PS：如果你的工程是从Eclipse工程导入的，工程目录下可能找不到gradle.properties这个文件，这时可在C:\Users\用户\ .gradle文件夹下新建<br>gradle.properties文件并用文本编辑器打开，添加以上配置就可以了。<br><a href="http://www.jianshu.com/p/5eeb8bf92559?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq" target="_blank" rel="noopener">Android Studio加速编译方法汇总</a></p>
<h3 id="String和Stringbuilder区别"><a href="#String和Stringbuilder区别" class="headerlink" title="String和Stringbuilder区别"></a>String和Stringbuilder区别</h3><p>String：字符串常量,如果要操作少量的数据用<br>StringBuilder：字符串变量,单线程操作字符串缓冲区下操作大量数据用</p>
<h3 id="Handler内存泄漏原因"><a href="#Handler内存泄漏原因" class="headerlink" title="Handler内存泄漏原因"></a>Handler内存泄漏原因</h3><p>1.在Java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用，由于Handler是非静态内部类所以其持有当前Activity的隐式引用，如果Handler没有被释放，其所持有的外部引用也就是Activity也不可能被释放，当一个对象一句不需要再使用了，本来该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中这就产生了内存泄漏，最终也就造成了OOM……<br>2.Handler、Message、MessageQueue是相互关联在一起的，Handler通过发送消息Message与主线程进行交互，如果Handler发送的消息Message尚未被处理，该Message及发送它的Handler对象将被MessageQueue一直持有，这样就可能会导致Handler无法被回收。</p>
<h3 id="弱引用、强引用用途"><a href="#弱引用、强引用用途" class="headerlink" title="弱引用、强引用用途"></a>弱引用、强引用用途</h3><p>1．强引用<br>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;</span><br><span class="line">  List&lt;String&gt; list = new Arraylist&lt;String&gt;();</span><br><span class="line">  list.add(str);</span><br><span class="line">  在list集合里的数据不会释放，即使内存不足也不会</span><br></pre></td></tr></table></figure>
<p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object c = new Car(); //只要c还指向car object, car object就不会被回收</span><br><span class="line">WeakReference&lt;Car&gt; weakCar = new WeakReference(Car)(car);</span><br></pre></td></tr></table></figure></p>
<p>当要获得weak reference引用的object时, 首先需要判断它是否已经被回收:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weakCar.get();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>强引用：<br>String str = “abc”;<br>list.add(str); </li>
<li>软引用：<br>如果弱引用对象回收完之后，内存还是报警，继续回收软引用对象 </li>
<li>弱引用：<br>如果虚引用对象回收完之后，内存还是报警，继续回收弱引用对象 </li>
<li>虚引用：<br>虚拟机的内存不够使用，开始报警，这时候垃圾回收机制开始执行System.gc(); String s = “abc”;如果没有对象回收了， 就回收没虚引用的对象</li>
</ul>
<h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><p>1.复用重写getView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">		public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">			View view;</span><br><span class="line">			// 判断convertView的状态，来达到复用效果</span><br><span class="line">			if (null == convertView) &#123;</span><br><span class="line">				//如果convertView为空，则表示第一次显示该条目，需要创建一个view</span><br><span class="line">				view = View.inflate(MainActivity.this, R.layout.listview_item,</span><br><span class="line">						null);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				//否则表示可以复用convertView</span><br><span class="line">				view = convertView;</span><br><span class="line">			&#125;</span><br><span class="line">			// listview_item里只有一个textview</span><br><span class="line">			TextView tv_item = (TextView) view.findViewById(R.id.tv_item);</span><br><span class="line">			tv_item.setText(list.get(position));</span><br><span class="line">			return view;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.新建一个内部静态类复用view<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static class ViewHolder &#123;</span><br><span class="line">		private TextView tvHolder;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.分页加载数据</p>
<h3 id="如何提高引用扩展性"><a href="#如何提高引用扩展性" class="headerlink" title="如何提高引用扩展性"></a>如何提高引用扩展性</h3><p>这个~~~我也不清楚</p>
<h3 id="重构准则"><a href="#重构准则" class="headerlink" title="重构准则"></a>重构准则</h3><ul>
<li>添加功能时一并重构；<br>修补错误时一并重构；<br>复审代码时一并重构； </li>
<li>重构可提高软件质量（改善设计、提升可读性、减少错误），良好设计是快速软件开发的根本。</li>
</ul>
<h3 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h3><p>为了避免ANR，我们会通常把 耗时操作放在子线程里面去执行，因为子线程不能更新UI，所以当子线程需要更新的UI的时候就需要借助到安卓的消息机制，也就是Handler机制了</p>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul>
<li>leep是Thread类的静态方法。sleep的作用是让线程休眠制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行</li>
<li><p>wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者</p>
</li>
<li><p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。</p>
</li>
<li><p>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</p>
</li>
<li><p>在调用sleep()方法的过程中，线程不会释放对象锁。</p>
</li>
<li><p>而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备</p>
</li>
</ul>
<p>获取对象锁进入运行状态。</p>
<h3 id="String，StringBuffer，StringBuilder的区别，哪个是线程安全的"><a href="#String，StringBuffer，StringBuilder的区别，哪个是线程安全的" class="headerlink" title="String，StringBuffer，StringBuilder的区别，哪个是线程安全的"></a>String，StringBuffer，StringBuilder的区别，哪个是线程安全的</h3><ul>
<li>String 字符串常量</li>
<li>StringBuffer 字符串变量（线程安全）</li>
<li>StringBuilder 字符串变量（非线程安全）</li>
</ul>
<h3 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h3><ul>
<li>Measure - Layout - Draw<br>measure过程的核心方法: measure() - onMeasure() - setMeasuredDimension().<br>子视图的具体位置都是相对于父视图而言的。View的onLayout()方法为空实现，而ViewGroup的onLayout为abstract，因此，自定义的View要继承ViewGroup时，必须实现onLayout函数。</li>
<li>所有视图最终都是调用View的draw方法进行绘制。 在自定义视图中， 也不应该复写该方法， 而是复写onDraw（）方法进行绘制， 如果自定义的视图确实要复写该方法，先调用super.draw()完成系统的绘制，再进行自定义的绘制。</li>
</ul>
<h3 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h3><ul>
<li>分发事件，默认为false。true：取消事件，不继续向下分发，false：向下分发事件<ul>
<li>拦截事件，默认为false。true：拦截事件，自身的onTouchEvent()方法消费，false：事件继续向下传递</li>
<li>处理事件，默认为false，true：消费事件，false：不消费事件，向上层传递让上层处理。【注】如果发生了拦截，那么如果该层不处理则会继续向上传递，让上层处理。如果过程中没有发生处理，则事件分发到底层后将一直向上层传递至Activity，在Activity的onTouchEvent()中处理。【注】如果在设置了setOnClickListener(…)的View或Viewgroup中，返回true则消费事件，会触发onClick事件，如果返回false，则不会触发onClick事件</li>
</ul>
</li>
</ul>
<h1 id="JAVA-相关"><a href="#JAVA-相关" class="headerlink" title="JAVA 相关"></a>JAVA 相关</h1><p>1.静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用?持有的引用是this?还是其它?</p>
<p>静态内部类：使用static修饰的内部类</p>
<p>内部类：就是在某个类的内部又定义了一个类，内部类所嵌入的类称为外部类</p>
<p>匿名内部类：使用new生成的内部类</p>
<p>因为内部类的产生依赖于外部类，持有的引用是类名.this</p>
<p>2.Java中try catch finally的执行顺序</p>
<p>先执行try中代码，如果发生异常执行catch中代码，最后一定会执行finally中代码</p>
<p>3.equals与==的区别：</p>
<p>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相</p>
<p>4.Object有哪些公用方法?</p>
<p>方法equals测试的是两个对象是否相等</p>
<p>方法clone进行对象拷贝</p>
<p>方法getClass返回和当前对象相关的Class对象</p>
<p>方法notify,notifyall,wait都是用来对给定对象进行线程同步的</p>
<p>5.String、StringBuffer与StringBuilder的区别</p>
<p>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象 StringBuffer和StringBuilder底层是 char[]数组实现的 StringBuffer是线程安全的，而StringBuilder是线程不安全的</p>
<p>6.Java的四种引用的区别</p>
<p>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</p>
<p>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</p>
<p>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</p>
<p>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</p>
<p>7.介绍垃圾回收机制</p>
<p>标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片</p>
<p>标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率</p>
<p>复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。</p>
<p>分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法</p>
<h1 id="集合、数据结构相关"><a href="#集合、数据结构相关" class="headerlink" title="集合、数据结构相关"></a>集合、数据结构相关</h1><p>1.你用过哪些集合类</p>
<p>数据结构中用于存储数据的有哪些</p>
<p>数组</p>
<p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1);数组的特点是：寻址容易，插入和删除困难;</p>
<p>链表</p>
<p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：寻址困难，插入和删除容易。</p>
<p>2.说说hashMap是怎样实现的</p>
<p>哈希表:由数组+链表组成的</p>
<p>当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置(即下标)，如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>3.ArrayList,LinkedList的区别</p>
<p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</p>
<p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p>
<p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p>
<p>4.ArrayList和Vector的主要区别是什么?</p>
<p>ArrayList 和Vector底层是采用数组方式存储数据</p>
<p>Vector:</p>
<p>线程同步</p>
<p>当Vector中的元素超过它的初始大小时，Vector会将它的容量翻倍，</p>
<p>ArrayList:</p>
<p>线程不同步，但性能很好</p>
<p>当ArrayList中的元素超过它的初始大小时，ArrayList只增加50%的大小</p>
<p>5.HashMap和 HashTable 的区别：</p>
<p>HashTable比较老，是基于Dictionary 类实现的，HashTable 则是基于 Map接口实现的</p>
<p>HashTable 是线程安全的， HashMap 则是线程不安全的</p>
<p>HashMap可以让你将空值作为一个表的条目的key或value</p>
<p>算法相关</p>
<p>1.排序算法和稳定性，快排什么时候情况最坏?</p>
<p>2.给最外层的rootview，把这个根视图下的全部button背景设置成红色，手写代码，不许用递归</p>
<p>算法原理：</p>
<p>Android的view视图是按树形结构分布，所以按树形结构遍历</p>
<p>循环判断每一层的ViewGroup元素，将其入栈;否则判断当前view是否是Button类实例，是则改写背景色</p>
<p>当前ViewGroup检查childView完成后，判断栈是否非空，取出栈顶元素ViewGroup重复步骤2直至栈为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void changeAllBtnBGColor(View view, int color) &#123;</span><br><span class="line">if (view == null || !(view instanceof ViewGroup))</span><br><span class="line">return; </span><br><span class="line">Stack m = new Stack&lt;&gt;();</span><br><span class="line">while (view != null) &#123; </span><br><span class="line">ViewGroup tmpGroup = (ViewGroup) view; </span><br><span class="line">int count = tmpGroup.getChildCount(); </span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123; View child = tmpGroup.getChildAt(i);</span><br><span class="line">if (child instanceof ViewGroup) m.add(child); </span><br><span class="line">else if (child instanceof Button) &#123; child.setBackgroundColor(color);</span><br><span class="line">&#125; &#125; </span><br><span class="line">if (m.isEmpty()) break; </span><br><span class="line">else view = m.pop();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Thread、AsynTask相关"><a href="#Thread、AsynTask相关" class="headerlink" title="Thread、AsynTask相关"></a>Thread、AsynTask相关</h1><p>1.wait()和sleep()的区别<br>sleep来自Thread类，和wait来自Object类</p>
<p>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</p>
<p>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</p>
<p>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒</p>
<p>2.若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?</p>
<p>当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常</p>
<p>同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</p>
<p>3.Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决?</p>
<p>还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新</p>
<p>4.Android 线程间通信有哪几种方式(重要)</p>
<p>共享内存(变量);</p>
<p>文件，数据库;</p>
<p>Handler;</p>
<p>Java 里的 wait()，notify()，notifyAll()</p>
<p>5.请介绍下 AsyncTask的内部实现，适用的场景是</p>
<p>AsyncTask 内部也是 Handler 机制来完成的，只不过 Android 提供了执行框架来提供线程池来</p>
<p>执行相应地任务，因为线程池的大小问题，所以 AsyncTask 只应该用来执行耗时时间较短的任务，</p>
<p>比如 HTTP 请求，大规模的下载和数据库的更改不适用于 AsyncTask，因为会导致线程池堵塞，没有</p>
<p>线程来执行其他的任务，导致的情形是会发生 AsyncTask 根本执行不了的问题。</p>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><p>1.TCP三次握手</p>
<p>2.为什么TCP是可靠的，UDP早不可靠的?为什么UDP比TCP快?</p>
<p>TCP/IP协议高，因为其拥有三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。</p>
<p>UDP就没有了，udp信息发出后,不验证是否到达对方,所以不可靠。</p>
<p>但是就速度来说，还是UDP协议更高，毕竟其无需重复返回验证，只是一次性的</p>
<p>3.http协议了解多少，说说里面的协议头部有哪些字段?</p>
<p>http(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议;http请求由三部分组成，分别是：请求行、消息报头、请求正文。</p>
<p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头</p>
<p>4.https了解多少</p>
<p>HTTPS(全称：Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>5.谈谈 HTTP 中Get 和 Post 方法的区别</p>
<p>GET - 从指定的服务器中获取数据，明文发送内容</p>
<p>POST - 提交数据给指定的服务器处理</p>
<ol>
<li><p>POST请求不能被缓存下来</p>
</li>
<li><p>POST请求不会保存在浏览器浏览记录中</p>
</li>
<li><p>以POST请求的URL无法保存为浏览器书签</p>
</li>
<li><p>POST请求没有长度限制</p>
</li>
</ol>
<p>6.推送心跳包是TCP包还是UDP包或者HTTP包</p>
<p>心跳包的实现是调用了socket.sendUrgentData(0xFF)这句代码实现的，所以，当然是TCP包。</p>
<p>7.如何实现文件断点上传</p>
<p>在 Android 中上传文件可以采用 HTTP 方式，也可以采用 Socket 方式，但是 HTTP 方式不能上传</p>
<p>大文件，这里介绍一种通过 Socket 方式来进行断点续传的方式，服务端会记录下文件的上传进度，</p>
<p>当某一次上传过程意外终止后，下一次可以继续上传，这里用到的其实还是 J2SE 里的知识。</p>
<p>这个上传程序的原理是：客户端第一次上传时向服务端发送</p>
<p>“Content-Length=35;filename=WinRAR_3.90_SC.exe;sourceid=“这种格式的字符串，服务端</p>
<p>收到后会查找该文件是否有上传记录，如果有就返回已经上传的位置，否则返回新生成的 sourceid</p>
<p>以及 position 为 0，类似 sourceid=2324838389;position=0“这样的字符串，客户端收到返回后</p>
<p>的字符串后再从指定的位置开始上传文件。</p>
<h1 id="Fragment相关"><a href="#Fragment相关" class="headerlink" title="Fragment相关"></a>Fragment相关</h1><p>1.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的?</p>
<p>Fragment 的事物管理器内部维持了一个双向链表结构，该结构可以记录我们每次 add 的</p>
<p>Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮的时候会自动帮我们实现退栈操作。</p>
<p>2.Fragment 在你们项目中的使用</p>
<p>Fragment 是 android3.0 以后引入的的概念，做局部内容更新更方便，原来为了到达这一点要</p>
<p>把多个布局放到一个 activity 里面，现在可以用多 Fragment 来代替，只有在需要的时候才加载</p>
<p>Fragment，提高性能。</p>
<p>Fragment 的好处：</p>
<ol>
<li>Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有它自己的生命周期和</li>
</ol>
<p>UI。</p>
<ol>
<li>Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电</li>
</ol>
<p>脑。</p>
<ol>
<li>Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中动态地移除、加入、</li>
</ol>
<p>交换等。</p>
<ol>
<li><p>Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI。</p>
</li>
<li><p>Fragment 解决 Activity 间的切换不流畅，轻量切换。</p>
</li>
<li><p>Fragment 替代 TabActivity 做导航，性能更好。</p>
</li>
<li><p>Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的界面效果</p>
</li>
</ol>
<p>3.如何切换 fragement,不重新实例化</p>
<p>正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment;再次切换时，只需 hide()当前，</p>
<p>show()另一个</p>
<h1 id="四大组件相关"><a href="#四大组件相关" class="headerlink" title="四大组件相关"></a>四大组件相关</h1><p>1.Activity和Fragment生命周期有哪些?</p>
<p>Activity——onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy</p>
<p>Fragment——onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach</p>
<p>2.广播的两种注册方式及有什么区别</p>
<p>3.内存不足时，怎么保持Activity的一些状态，在哪个方法里面做具体操作?</p>
<p>Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况(如：内存不足、用户直接按Home键)由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。</p>
<p>4.启动service的两种方法?有什么区别?</p>
<p>一种是startService(),另一种是bindService()。这两者的区别是第一种方式调用者开启了服务，即会与服务失去联系，两者没有关联。即使访问者退出了，服务仍在运行。如需解除服务必须显式的调用stopService方法。主要用于调用者与服务没有交互的情况下，也就是调用者不需要获取服务里的业务方法。比如电话录音。而后者调用者与服务绑定在一起的。当调用者退出的时候，服务也随之退出。用于需要与服务交互。</p>
<p>5.Android中的Context, Activity，Appliction有什么区别?</p>
<p>相同：Activity和Application都是Context的子类。</p>
<p>Context从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理上下文环境中各个参数和变量的总用，方便我们可以简单的访问到各种资源。</p>
<p>不同：维护的生命周期不同。 Context维护的是当前的Activity的生命周期，Application维护的是整个项目的生命周期。</p>
<p>使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>
<ol>
<li><p>不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的。</p>
</li>
<li><p>对于生命周期长的对象，可以使用application，context。</p>
</li>
<li><p>避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。</p>
</li>
</ol>
<p>6.Context是什么?</p>
<p>它描述的是一个应用程序环境的信息，即上下文。</p>
<p>该类是一个抽象(abstract class)类，Android提供了该抽象类的具体实现类(ContextIml)。</p>
<p>通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播，接受Intent，信息，等。</p>
<p>7.Service 是否在 main thread 中执行, service 里面是否能执行耗时的操</p>
<p>作?</p>
<p>默认情况,如果没有显示的指 servic 所运行的进程, Service 和 activity 是运行在当前 app 所在进</p>
<p>程的 main thread(UI 主线程)里面。</p>
<p>service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )</p>
<p>特殊情况 ,可以在清单文件配置 service 执行所在的进程 ,让 service 在另外的进程中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service </span><br><span class="line">android:name=&quot;com.baidu.location.f&quot;</span><br><span class="line">android:enabled=&quot;true&quot;</span><br><span class="line">android:process=&quot;:remote&quot; &gt; </span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></p>
<p>8.Activity 怎么和 Service 绑定，怎么在 Activity 中启动自己对应的</p>
<p>Service?</p>
<p>Activity 通过 bindService(Intent service, ServiceConnection conn, int flags)跟 Service 进行</p>
<p>绑定，当绑定成功的时候 Service 会将代理对象通过回调的形式传给 conn，这样我们就拿到了</p>
<p>Service 提供的服务代理对象。</p>
<p>在 Activity 中可以通过 startService 和 bindService 方法启动 Service。一般情况下如果想获取</p>
<p>Service 的服务对象那么肯定需要通过 bindService()方法，比如音乐播放器，第三方支付等。如</p>
<p>果仅仅只是为了开启一个后台任务那么可以使用 startService()方法。</p>
<p>9.说说 Activity、Intent、Service 是什么关系</p>
<p>他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是 Android 四大组件</p>
<p>之一。他俩都是 Context 类的子类 ContextWrapper 的子类，因此他俩可以算是兄弟关系吧。不过</p>
<p>兄弟俩各有各自的本领，Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。Activity</p>
<p>和 Service 之间可以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者。</p>
<p>10.请描述一下 BroadcastReceiver</p>
<p>BroadCastReceiver 是 Android 四大组件之一，主要用于接收系统或者 app 发送的广播事件。</p>
<p>广播分两种：有序广播和无序广播。</p>
<p>内部通信实现机制：通过 Android 系统的 Binder 机制实现通信。</p>
<ol>
<li>无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不</li>
</ol>
<p>能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。</p>
<ol>
<li>有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者 A，B，C，</li>
</ol>
<p>优先级是 A &gt; B &gt; C。那这个消息先传给 A，再传给 B，最后传给 C。每个接收者有权终止广播，比</p>
<p>如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，</p>
<p>B 可以从结果对象中取得 A 存入的数据。</p>
<p>在通过 Context.sendOrderedBroadcast(intent, receiverPermission, resultReceiver, scheduler,</p>
<p>initialCode, initialData, initialExtras)时我们可以指定 resultReceiver 广播接收者，这个接收者我们</p>
<p>可以认为是最终接收者，通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的</p>
<p>onReceive 会被执行两次，第一次是正常的按照优先级顺序执行，第二次是作为最终接收者接收。</p>
<p>如果比他优先级高的接收者终止了广播，那么他依然能接收到广播</p>
<p>11.为什么要用 ContentProvider?它和 sql 的实现上有什么差别?</p>
<p>ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的</p>
<p>uri 就可以了，ContentProvider 可以实现不同 app 之间共享。</p>
<p>Sql 也有增删改查的方法，但是 sql 只能查询本应用下的数据库。而 ContentProvider 还可</p>
<p>以去增删改查本地文件. xml 文件的读取等。</p>
<p>12.说说 ContentProvider、ContentResolver、ContentObserver 之间的关系</p>
<p>a. ContentProvider 内容提供者，用于对外提供数据</p>
<p>b. ContentResolver.notifyChange(uri)发出消息</p>
<p>c. ContentResolver 内容解析者，用于获取内容提供者提供的数据</p>
<p>d. ContentObserver 内容监听器，可以监听数据的改变状态</p>
<p>e. ContentResolver.registerContentObserver()监听消息。</p>
<h1 id="View-相关"><a href="#View-相关" class="headerlink" title="View 相关"></a>View 相关</h1><p>1.onInterceptTouchEvent()和onTouchEvent()的区别</p>
<p>onInterceptTouchEvent()用于拦截触摸事件</p>
<p>onTouchEvent()用于处理触摸事件</p>
<p>2.RemoteView在哪些功能中使用</p>
<p>APPwidget和Notification中</p>
<ol>
<li>SurfaceView和View的区别是什么?</li>
</ol>
<p>SurfaceView中采用了双缓存技术，在单独的线程中更新界面</p>
<p>View在UI线程中更新界面</p>
<p>4.View的绘制过程</p>
<p>一个View要显示在界面上，需要经历一个View树的遍历过程，这个过程又可以分为三个过程，也就是自定义View中的三要素：大小，位置，画什么，即onMesure()，onLayout(),onDraw()。</p>
<p>1.onMesure()确定一个View的大小;</p>
<p>2.onLayout()确定View在父节点上的位置;</p>
<p>3.onDraw()绘制View 的内容;</p>
<p>5.如何自定义ViewGroup</p>
<p>1.指定的LayoutParams</p>
<p>2.onMeasure中计算所有childView的宽和高，然后根据childView的宽和高，计算自己的宽和高。(当然，如果不是wrap_content，直接使用父ViewGroup传入的计算值即可)</p>
<p>3.onLayout中对所有的childView进行布局。</p>
<p>6.View中onTouch，onTouchEvent，onClick的执行顺序</p>
<p>dispatchTouchEvent—-&gt;onTouch—-&gt;onTouchEvent—–&gt;onClick。在所有ACTION_UP事件之后才触发onClick点击事件。</p>
<h1 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h1><p>1.ListView卡顿的原因与性能优化，越多越好</p>
<p>重用converView： 通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</p>
<p>减少findViewById()操作： 将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</p>
<p>避免在 getView 方法中做耗时的操作: 例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</p>
<p>Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</p>
<p>尽量能保证 Adapter 的 hasStableIds() 返回 true 这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的</p>
<p>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。 由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现</p>
<p>使用 RecycleView 代替listview： 每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</p>
<p>ListView 中元素避免半透明： 半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。 在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</p>
<p>尽量开启硬件加速： 硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</p>
<p>2.如何避免 OOM 问题的出现</p>
<p>使用更加轻量的数据结构 例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效，在于他们避免了对key与value的自动装箱(autoboxing)，并且避免了装箱后的解箱。</p>
<p>避免在Android里面使用Enum Android官方培训课程提到过“Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.”，具体原理请参考《Android性能优化典范(三)》，所以请避免在Android里面使用到枚举。</p>
<p>减小Bitmap对象的内存占用 Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用可谓是重中之重，，通常来说有以下2个措施： ++inSampleSize++：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 ++decode format++：解码格式，选择ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异</p>
<p>Bitmap对象的复用 缩小Bitmap的同时，也需要提高BitMap对象的复用率，避免频繁创建BitMap对象，复用的方法有以下2个措施 LRUCache : “最近最少使用算法”在Android中有极其普遍的应用。ListView与GridView等显示大量图片的控件里，就是使用LRU的机制来缓存处理好的Bitmap，把近期最少使用的数据从缓存中移除，保留使用最频繁的数据， inBitMap高级特性:利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小</p>
<p>使用更小的图片 在涉及给到资源图片时，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用更小的图片。尽量使用更小的图片不仅可以减少内存的使用，还能避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图时会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p>
<p>StringBuilder 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>
<p>避免在onDraw方法里面执行对象的创建 类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>
<p>避免对象的内存泄露</p>
<p>3.三级缓存的原理</p>
<p>从缓存中加载。</p>
<p>从本地文件中加载(数据库，SD)</p>
<p>从网络加载。</p>
<p>a.加载 bitmap 的时候无需考虑 bitmap 加载过程中出现的 oom(内存溢出)和 android 容器快速</p>
<p>滑动的时候出现的图片错位等现象。(16M)</p>
<p>b. 支持加载网络图片和本地图片。</p>
<p>c. 内存管理使用的 lru 算法(移除里面是有频率最少的对象)，更好的管理 bitmap 的内存</p>
<h1 id="Android其他"><a href="#Android其他" class="headerlink" title="Android其他"></a>Android其他</h1><p>1.讲一下android中进程的优先级?</p>
<p>前台进程</p>
<p>可见进程</p>
<p>服务进程</p>
<p>后台进程</p>
<p>空进程</p>
<p>2.介绍Handle的机制</p>
<p>Handler通过调用sendmessage方法把消息放在消息队列MessageQueue中，Looper负责把消息从消息队列中取出来，重新再交给Handler进行处理，三者形成一个循环</p>
<p>通过构建一个消息队列，把所有的Message进行统一的管理，当Message不用了，并不作为垃圾回收，而是放入消息队列中，供下次handler创建消息时候使用，提高了消息对象的复用，减少系统垃圾回收的次数</p>
<p>每一个线程，都会单独对应的一个looper，这个looper通过ThreadLocal来创建，保证每个线程只创建一个looper，looper初始化后就会调用looper.loop创建一个MessageQueue，这个方法在UI线程初始化的时候就会完成，我们不需要手动创建</p>
<p>3.Dalvik虚拟机与JVM有什么区别</p>
<p>Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。</p>
<p>Dalvik执行.dex格式的字节码，而JVM执行.class格式的字节码。</p>
<p>4.每个应用程序对应多少个Dalvik虚拟机</p>
<p>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行 ，而所有的Android应用的线程都对应一个Linux线程</p>
<p>5.应用常驻后台，避免被第三方杀掉的方法</p>
<p>Service设置成START_STICKY kill 后会被重启(等待5秒左右)，重传Intent，保持与重启前一样</p>
<p>通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill</p>
<p>双进程Service： 让2个进程互相保护对方，其中一个Service被清理后，另外没被清理的进程可以立即重启进程</p>
<p>用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响(Android5.0以上的版本不可行</p>
<p>联系厂商，加入白名单</p>
<p>6.根据自己的理解描述下Android数字签名。</p>
<p>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序</p>
<p>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证</p>
<p>如果要正式发布一个Android程序，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。</p>
<p>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</p>
<p>7.Dalvik基于JVM的改进</p>
<p>几个class变为一个dex，constant pool，省内存</p>
<p>Zygote，copy-on-write shared,省内存，省cpu，省电</p>
<p>基于寄存器的bytecode，省指令，省cpu，省电</p>
<p>Trace-based JIT,省cpu，省电,省内存</p>
<p>8.ARGB_8888占用内存大小</p>
<p>本题的答案，是4byte，即ARGB各占用8个比特来描述。</p>
<p>9.apk安装卸载的原理</p>
<p>安装过程：复制apk安装包到data/app目录下，解压并扫描安装包，把dex文件(dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录。</p>
<p>卸载过程：删除安装过程中在上述三个目录下创建的文件及目录。</p>
<p>10.通过Intent传递一些二进制数据的方法有哪些?</p>
<p>使用Serializable接口实现序列化，这是Java常用的方法。</p>
<p>实现Parcelable接口，这里Android的部分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见的。</p>
<p>11.横竖屏切换时Activity的生命周期</p>
<p>此时的生命周期跟清单文件里的配置有关系。</p>
<p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期默认首先销毁当前activity,然后重新加载。</p>
<p>设置Activity android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
<p>12.Serializable 和 Parcelable 的区别</p>
<p>在使用内存的时候，Parcelable 类比 Serializable 性能高，所以推荐使用 Parcelable 类。</p>
<ol>
<li><p>Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。</p>
</li>
<li><p>Parcelable 不能使用在要将数据存储在磁盘上的情况。尽管 Serializable 效率低点，但在这</p>
</li>
</ol>
<p>种情况下，还是建议你用 Serializable 。</p>
<p>13.Android 中如何捕获未捕获的异常</p>
<p>自 定 义 一 个 Application ， 比 如 叫 MyApplication 继 承 Application 实 现</p>
<p>UncaughtExceptionHandler。</p>
<p>覆写 UncaughtExceptionHandler 的 onCreate 和 uncaughtException 方法。</p>
<p>14.Android 的权限规则</p>
<p>Android 中的 apk 必须签名</p>
<p>基于 UserID 的进程级别的安全机制</p>
<p>默认 apk 生成的数据对外是不可见的</p>
<p>AndroidManifest.xml 中的显式权限声明</p>
<p>15.多线程间通信和多进程之间通信有什么不同，分别怎么实现?</p>
<p>一、进程间的通信方式</p>
<ol>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的</li>
</ol>
<p>进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<ol>
<li>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的</li>
</ol>
<p>通信。</p>
<ol>
<li>信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它</li>
</ol>
<p>常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进</p>
<p>程间以及同一进程内不同线程之间的同步手段。</p>
<ol>
<li>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符</li>
</ol>
<p>标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<ol>
<li><p>信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内</p>
</li>
</ol>
<p>存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间</p>
<p>通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间</p>
<p>的同步和通信。</p>
<ol>
<li>套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同</li>
</ol>
<p>及其间的进程通信。</p>
<p>二、线程间的通信方式</p>
<ol>
<li>锁机制：包括互斥锁、条件变量、读写锁</li>
</ol>
<p>*互斥锁提供了以排他方式防止数据结构被并发修改的方法。</p>
<p>*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</p>
<p>*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁</p>
<p>的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<ol>
<li><p>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</p>
</li>
<li><p>信号机制(Signal)：类似进程间的信号处理</p>
</li>
</ol>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机</p>
<p>制。</p>
<p>16.说说 LruCache 底层原理</p>
<p>LruCache 使用一个 LinkedHashMap 简单的实现内存的缓存，没有软引用，都是强引用。如果添</p>
<p>加的数据大于设置的最大值，就删除最先缓存的数据来调整内存。</p>
<p>maxSize 是通过构造方法初始化的值，他表示这个缓存能缓存的最大值是多少。</p>
<p>size 在添加和移除缓存都被更新值，他通过 safeSizeOf 这个方法更新值。safeSizeOf 默认返回 1，</p>
<p>但一般我们会根据 maxSize 重写这个方法，比如认为 maxSize 代表是 KB 的话，那么就以 KB 为单</p>
<p>位返回该项所占的内存大小。</p>
<p>除异常外首先会判断 size 是否超过 maxSize，如果超过了就取出最先插入的缓存，如果不为空就</p>
<p>删掉，并把 size 减去该项所占的大小。这个操作将一直循环下去，直到 size 比 maxSize 小或者缓存</p>
<p>为空。</p>
<h2 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h2><p>AndroidFire，一款新闻阅读 App框架，基于 Material Design + MVP + RxJava + Retrofit + Glide，<br>基本涵盖了当前 Android 端开发最常用的主流框架，基于此框架可以快速开发一个app。</p>
<h2 id="GitHub-源码"><a href="#GitHub-源码" class="headerlink" title="GitHub 源码"></a><a href="https://github.com/jaydenxiao2016/AndroidFire" target="_blank" rel="noopener">GitHub 源码</a></h2>
      
    </div>
    
  </div>
  
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/03/15/Android面试总结(问答)/">Android面试总结(问答篇)</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">appzy</a></p>
        <p><span>发布时间:</span>2017-03-15, 22:55:00</p>
        <p><span>最后更新:</span>2017-03-15, 22:55:00</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/03/15/Android面试总结(问答)/" title="Android面试总结(问答篇)">http://appzy.vip/2017/03/15/Android面试总结(问答)/</a>
            <span class="copy-path" data-clipboard-text="原文: http://appzy.vip/2017/03/15/Android面试总结(问答)/　　作者: appzy" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/05/19/Android面试总结/">
                    Android面试总结
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/02/11/设计模式之单例模式/">
                    设计模式之单例模式
                </a>
            </div>
        
    </nav>
  
</article>
<div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized锁静态方法和非静态方法的区别"><span class="toc-number">1.</span> <span class="toc-text"><a href="#synchronized&#x9501;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x548C;&#x975E;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x7684;&#x533A;&#x522B;" class="headerlink" title="synchronized&#x9501;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x548C;&#x975E;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x7684;&#x533A;&#x522B;"></a>synchronized&#x9501;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x548C;&#x975E;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-和Integer的区别"><span class="toc-number">2.</span> <span class="toc-text"><a href="#int-&#x548C;Integer&#x7684;&#x533A;&#x522B;" class="headerlink" title="int &#x548C;Integer&#x7684;&#x533A;&#x522B;"></a>int &#x548C;Integer&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏有哪些？原因？"><span class="toc-number">3.</span> <span class="toc-text"><a href="#&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x6709;&#x54EA;&#x4E9B;&#xFF1F;&#x539F;&#x56E0;&#xFF1F;" class="headerlink" title="&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x6709;&#x54EA;&#x4E9B;&#xFF1F;&#x539F;&#x56E0;&#xFF1F;"></a>&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x6709;&#x54EA;&#x4E9B;&#xFF1F;&#x539F;&#x56E0;&#xFF1F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卡顿的根本原因？怎么处理？"><span class="toc-number">4.</span> <span class="toc-text"><a href="#&#x5361;&#x987F;&#x7684;&#x6839;&#x672C;&#x539F;&#x56E0;&#xFF1F;&#x600E;&#x4E48;&#x5904;&#x7406;&#xFF1F;" class="headerlink" title="&#x5361;&#x987F;&#x7684;&#x6839;&#x672C;&#x539F;&#x56E0;&#xFF1F;&#x600E;&#x4E48;&#x5904;&#x7406;&#xFF1F;"></a>&#x5361;&#x987F;&#x7684;&#x6839;&#x672C;&#x539F;&#x56E0;&#xFF1F;&#x600E;&#x4E48;&#x5904;&#x7406;&#xFF1F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvc、mvp、mvvm"><span class="toc-number">5.</span> <span class="toc-text"><a href="#mvc&#x3001;mvp&#x3001;mvvm" class="headerlink" title="mvc&#x3001;mvp&#x3001;mvvm"></a>mvc&#x3001;mvp&#x3001;mvvm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RxJava特点"><span class="toc-number">6.</span> <span class="toc-text"><a href="#RxJava&#x7279;&#x70B9;" class="headerlink" title="RxJava&#x7279;&#x70B9;"></a>RxJava&#x7279;&#x70B9;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断对象可以被GC"><span class="toc-number">7.</span> <span class="toc-text"><a href="#&#x5982;&#x4F55;&#x5224;&#x65AD;&#x5BF9;&#x8C61;&#x53EF;&#x4EE5;&#x88AB;GC" class="headerlink" title="&#x5982;&#x4F55;&#x5224;&#x65AD;&#x5BF9;&#x8C61;&#x53EF;&#x4EE5;&#x88AB;GC"></a>&#x5982;&#x4F55;&#x5224;&#x65AD;&#x5BF9;&#x8C61;&#x53EF;&#x4EE5;&#x88AB;GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化有哪些"><span class="toc-number">8.</span> <span class="toc-text"><a href="#&#x6027;&#x80FD;&#x4F18;&#x5316;&#x6709;&#x54EA;&#x4E9B;" class="headerlink" title="&#x6027;&#x80FD;&#x4F18;&#x5316;&#x6709;&#x54EA;&#x4E9B;"></a>&#x6027;&#x80FD;&#x4F18;&#x5316;&#x6709;&#x54EA;&#x4E9B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保活"><span class="toc-number">9.</span> <span class="toc-text"><a href="#&#x5982;&#x4F55;&#x4FDD;&#x6D3B;" class="headerlink" title="&#x5982;&#x4F55;&#x4FDD;&#x6D3B;"></a>&#x5982;&#x4F55;&#x4FDD;&#x6D3B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webview问题简述"><span class="toc-number">10.</span> <span class="toc-text"><a href="#Webview&#x95EE;&#x9898;&#x7B80;&#x8FF0;" class="headerlink" title="Webview&#x95EE;&#x9898;&#x7B80;&#x8FF0;"></a>Webview&#x95EE;&#x9898;&#x7B80;&#x8FF0;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#As编译慢，怎么提速"><span class="toc-number">11.</span> <span class="toc-text"><a href="#As&#x7F16;&#x8BD1;&#x6162;&#xFF0C;&#x600E;&#x4E48;&#x63D0;&#x901F;" class="headerlink" title="As&#x7F16;&#x8BD1;&#x6162;&#xFF0C;&#x600E;&#x4E48;&#x63D0;&#x901F;"></a>As&#x7F16;&#x8BD1;&#x6162;&#xFF0C;&#x600E;&#x4E48;&#x63D0;&#x901F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String和Stringbuilder区别"><span class="toc-number">12.</span> <span class="toc-text"><a href="#String&#x548C;Stringbuilder&#x533A;&#x522B;" class="headerlink" title="String&#x548C;Stringbuilder&#x533A;&#x522B;"></a>String&#x548C;Stringbuilder&#x533A;&#x522B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler内存泄漏原因"><span class="toc-number">13.</span> <span class="toc-text"><a href="#Handler&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x539F;&#x56E0;" class="headerlink" title="Handler&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x539F;&#x56E0;"></a>Handler&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x539F;&#x56E0;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弱引用、强引用用途"><span class="toc-number">14.</span> <span class="toc-text"><a href="#&#x5F31;&#x5F15;&#x7528;&#x3001;&#x5F3A;&#x5F15;&#x7528;&#x7528;&#x9014;" class="headerlink" title="&#x5F31;&#x5F15;&#x7528;&#x3001;&#x5F3A;&#x5F15;&#x7528;&#x7528;&#x9014;"></a>&#x5F31;&#x5F15;&#x7528;&#x3001;&#x5F3A;&#x5F15;&#x7528;&#x7528;&#x9014;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView优化"><span class="toc-number">15.</span> <span class="toc-text"><a href="#ListView&#x4F18;&#x5316;" class="headerlink" title="ListView&#x4F18;&#x5316;"></a>ListView&#x4F18;&#x5316;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何提高引用扩展性"><span class="toc-number">16.</span> <span class="toc-text"><a href="#&#x5982;&#x4F55;&#x63D0;&#x9AD8;&#x5F15;&#x7528;&#x6269;&#x5C55;&#x6027;" class="headerlink" title="&#x5982;&#x4F55;&#x63D0;&#x9AD8;&#x5F15;&#x7528;&#x6269;&#x5C55;&#x6027;"></a>&#x5982;&#x4F55;&#x63D0;&#x9AD8;&#x5F15;&#x7528;&#x6269;&#x5C55;&#x6027;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重构准则"><span class="toc-number">17.</span> <span class="toc-text"><a href="#&#x91CD;&#x6784;&#x51C6;&#x5219;" class="headerlink" title="&#x91CD;&#x6784;&#x51C6;&#x5219;"></a>&#x91CD;&#x6784;&#x51C6;&#x5219;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler机制"><span class="toc-number">18.</span> <span class="toc-text"><a href="#Handler&#x673A;&#x5236;" class="headerlink" title="Handler&#x673A;&#x5236;"></a>Handler&#x673A;&#x5236;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep和wait的区别"><span class="toc-number">19.</span> <span class="toc-text"><a href="#sleep&#x548C;wait&#x7684;&#x533A;&#x522B;" class="headerlink" title="sleep&#x548C;wait&#x7684;&#x533A;&#x522B;"></a>sleep&#x548C;wait&#x7684;&#x533A;&#x522B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String，StringBuffer，StringBuilder的区别，哪个是线程安全的"><span class="toc-number">20.</span> <span class="toc-text"><a href="#String&#xFF0C;StringBuffer&#xFF0C;StringBuilder&#x7684;&#x533A;&#x522B;&#xFF0C;&#x54EA;&#x4E2A;&#x662F;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x7684;" class="headerlink" title="String&#xFF0C;StringBuffer&#xFF0C;StringBuilder&#x7684;&#x533A;&#x522B;&#xFF0C;&#x54EA;&#x4E2A;&#x662F;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x7684;"></a>String&#xFF0C;StringBuffer&#xFF0C;StringBuilder&#x7684;&#x533A;&#x522B;&#xFF0C;&#x54EA;&#x4E2A;&#x662F;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x7684;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View的绘制流程"><span class="toc-number">21.</span> <span class="toc-text"><a href="#View&#x7684;&#x7ED8;&#x5236;&#x6D41;&#x7A0B;" class="headerlink" title="View&#x7684;&#x7ED8;&#x5236;&#x6D41;&#x7A0B;"></a>View&#x7684;&#x7ED8;&#x5236;&#x6D41;&#x7A0B;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件分发机制"><span class="toc-number">22.</span> <span class="toc-text"><a href="#&#x4E8B;&#x4EF6;&#x5206;&#x53D1;&#x673A;&#x5236;" class="headerlink" title="&#x4E8B;&#x4EF6;&#x5206;&#x53D1;&#x673A;&#x5236;"></a>&#x4E8B;&#x4EF6;&#x5206;&#x53D1;&#x673A;&#x5236;</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-相关"><span class="toc-number"></span> <span class="toc-text"><a href="#JAVA-&#x76F8;&#x5173;" class="headerlink" title="JAVA &#x76F8;&#x5173;"></a>JAVA &#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合、数据结构相关"><span class="toc-number"></span> <span class="toc-text"><a href="#&#x96C6;&#x5408;&#x3001;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x76F8;&#x5173;" class="headerlink" title="&#x96C6;&#x5408;&#x3001;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x76F8;&#x5173;"></a>&#x96C6;&#x5408;&#x3001;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread、AsynTask相关"><span class="toc-number"></span> <span class="toc-text"><a href="#Thread&#x3001;AsynTask&#x76F8;&#x5173;" class="headerlink" title="Thread&#x3001;AsynTask&#x76F8;&#x5173;"></a>Thread&#x3001;AsynTask&#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络相关"><span class="toc-number"></span> <span class="toc-text"><a href="#&#x7F51;&#x7EDC;&#x76F8;&#x5173;" class="headerlink" title="&#x7F51;&#x7EDC;&#x76F8;&#x5173;"></a>&#x7F51;&#x7EDC;&#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fragment相关"><span class="toc-number"></span> <span class="toc-text"><a href="#Fragment&#x76F8;&#x5173;" class="headerlink" title="Fragment&#x76F8;&#x5173;"></a>Fragment&#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四大组件相关"><span class="toc-number"></span> <span class="toc-text"><a href="#&#x56DB;&#x5927;&#x7EC4;&#x4EF6;&#x76F8;&#x5173;" class="headerlink" title="&#x56DB;&#x5927;&#x7EC4;&#x4EF6;&#x76F8;&#x5173;"></a>&#x56DB;&#x5927;&#x7EC4;&#x4EF6;&#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#View-相关"><span class="toc-number"></span> <span class="toc-text"><a href="#View-&#x76F8;&#x5173;" class="headerlink" title="View &#x76F8;&#x5173;"></a>View &#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#性能优化相关"><span class="toc-number"></span> <span class="toc-text"><a href="#&#x6027;&#x80FD;&#x4F18;&#x5316;&#x76F8;&#x5173;" class="headerlink" title="&#x6027;&#x80FD;&#x4F18;&#x5316;&#x76F8;&#x5173;"></a>&#x6027;&#x80FD;&#x4F18;&#x5316;&#x76F8;&#x5173;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android其他"><span class="toc-number"></span> <span class="toc-text"><a href="#Android&#x5176;&#x4ED6;" class="headerlink" title="Android&#x5176;&#x4ED6;"></a>Android&#x5176;&#x4ED6;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#福利"><span class="toc-number"></span> <span class="toc-text"><a href="#&#x798F;&#x5229;" class="headerlink" title="&#x798F;&#x5229;"></a>&#x798F;&#x5229;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GitHub-源码"><span class="toc-number"></span> <span class="toc-text"><a href="#GitHub-&#x6E90;&#x7801;" class="headerlink" title="GitHub &#x6E90;&#x7801;"></a><a href="https://github.com/jaydenxiao2016/AndroidFire" target="_blank" rel="noopener">GitHub &#x6E90;&#x7801;</a></span></a>
        
    </li></ol></li></div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>


    <div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Android面试总结(问答篇)　| appzy　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>



    


<div class="scroll" id="post-nav-button">
        
            <a href="/2017/05/19/Android面试总结/" title="上一篇: Android面试总结">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/02/11/设计模式之单例模式/" title="下一篇: 设计模式之单例模式">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/Glide源码分析解读-基于Glide 4.9.0/">Glide源码分析解读-基于Glide 4.9.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/jQuery夜晚天空满天星星闪烁动画/">jQuery夜晚天空满天星星闪烁动画（附源码）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Android 接入微信支付宝支付/">Android 接入微信支付宝支付</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/DeviceInfo采集android设备信息工具/">DeviceInfo采集android设备信息工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/25/Android 内存优化/">Android 内存优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/Android代码混淆干货/">Android代码混淆干货</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/26/webview详解和常见的问题/">webview详解和常见的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/Android面试总结/">Android面试总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/Android面试总结(问答)/">Android面试总结(问答篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/11/设计模式之单例模式/">设计模式之单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/可视化正则表达式/">可视化正则表达式整理</a></li></ul>


    <script>
        
    </script></div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 appzy
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架" rel="external nofollow">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5" rel="external nofollow">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    <script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>
<script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide()" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
