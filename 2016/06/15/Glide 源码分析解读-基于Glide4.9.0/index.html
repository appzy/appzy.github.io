<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="appzy">
<meta name="baidu-site-verification" content="s8Pe1TBqyy">



<meta name="description" content="Glide 源码很复杂， 涉及到的东西也很多，这里不能面面俱到，只是把我认为重要的东西介绍了一下，可能还有一些疏漏。 首先我将 Glide 分成了几个模块，让大家有个整体的印象，自顶向下的分析源码，从而实现降维打击。按照逻辑功能划分，可以把 Glide 框架大概的分成如下几个部分：">
<meta name="keywords" content="Glide">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide 源码分析解读-基于Glide 4.9.0">
<meta property="og:url" content="http://appzy.vip/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/index.html">
<meta property="og:site_name" content="appzy">
<meta property="og:description" content="Glide 源码很复杂， 涉及到的东西也很多，这里不能面面俱到，只是把我认为重要的东西介绍了一下，可能还有一些疏漏。 首先我将 Glide 分成了几个模块，让大家有个整体的印象，自顶向下的分析源码，从而实现降维打击。按照逻辑功能划分，可以把 Glide 框架大概的分成如下几个部分：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://appzy.vip/img/glide_overview.png">
<meta property="og:image" content="https://appzy.vip/img/glide_process.png">
<meta property="og:image" content="https://appzy.vip/img/glide_package.png">
<meta property="og:image" content="https://appzy.vip/img/request_method.png">
<meta property="og:image" content="https://appzy.vip/img/load_package.png">
<meta property="og:image" content="https://appzy.vip/img/cache_porcess.png">
<meta property="og:image" content="https://appzy.vip/img/grouped_linked_map.png">
<meta property="og:updated_time" content="2019-06-19T06:30:47.417Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide 源码分析解读-基于Glide 4.9.0">
<meta name="twitter:description" content="Glide 源码很复杂， 涉及到的东西也很多，这里不能面面俱到，只是把我认为重要的东西介绍了一下，可能还有一些疏漏。 首先我将 Glide 分成了几个模块，让大家有个整体的印象，自顶向下的分析源码，从而实现降维打击。按照逻辑功能划分，可以把 Glide 框架大概的分成如下几个部分：">
<meta name="twitter:image" content="https://appzy.vip/img/glide_overview.png">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="appzy" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Glide 源码分析解读-基于Glide 4.9.0 | appzy</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





  <style type="text/css">
  .div_right_bottom {
  width: 200px;
  top: 50%;
  right: 0px;
  position: fixed;
  margin-top: -100px;
  _position: absolute;
}
</style>
</head></html>
<body>
<div class="div_right_bottom" style="z-index:99" align="center">
  <img src="http://appzy.vip/images/csyl.jpg" height="180px" width="180px">
  微信公众号
  </div>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">appzy</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不为模糊不清的未来担忧，只为清清楚楚的现在努力。</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false">
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/appzy" title="GitHub"></a>
                            
                                <a class="fa Coding" href="https://coding.net/u/appzy/project" title="Coding"></a>
                            
                                <a class="fa 简书" href="http://www.jianshu.com/users/b2d0a8ba449b/timeline" title="简书"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/le-hu-95-55/activities" title="知乎"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" href="mailto:http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="http://weibo.com/login.php" title="新浪微博"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AndroidPay/">AndroidPay</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide/">Glide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-面试/">android 面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory/">memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webview/">webview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码混淆/">代码混淆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设备信息/">设备信息</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://appzy.vip">appzy</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://appzy.github.io/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Make progress every day and Never give up......</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">appzy</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">appzy</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不为模糊不清的未来担忧，只为清清楚楚的现在努力。</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/appzy" title="GitHub"></a>
                            
                                <a class="fa Coding" target="_blank" href="https://coding.net/u/appzy/project" title="Coding"></a>
                            
                                <a class="fa 简书" target="_blank" href="http://www.jianshu.com/users/b2d0a8ba449b/timeline" title="简书"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/le-hu-95-55/activities" title="知乎"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/login.php" title="新浪微博"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap"><article id="post-Glide 源码分析解读-基于Glide4.9.0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/" class="article-date">
      <time datetime="2016-06-15T03:25:00.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        <h1 class="article-title" itemprop="name">
      Glide 源码分析解读-基于Glide 4.9.0
    </h1>
      </header>
      
      <div class="article-info article-info-post">
        
        <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Glide/">Glide</a></li></ul>
    </div>
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Glide 源码很复杂， 涉及到的东西也很多，这里不能面面俱到，只是把我认为重要的东西介绍了一下，可能还有一些疏漏。</p>
<p>首先我将 Glide 分成了几个模块，让大家有个整体的印象，自顶向下的分析源码，从而实现降维打击。<br>按照逻辑功能划分，可以把 Glide 框架大概的分成如下几个部分：<br><a id="more"></a></p>
<p>项目基于最新版 <a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide 4.9.0 源码</a>分析，通过如下方式获取并编译代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bumptech/glide.git</span><br><span class="line">cd glide</span><br><span class="line">./gradlew jar</span><br></pre></td></tr></table></figure></p>
<p><img src="https://appzy.vip/img/glide_overview.png" alt="模块划分"></p>
<p>Glide 大体上可以分为如上几个模块。</p>
<p>下面通过一个常用案例来分析整个流程。<br>一般来说，我们使用如下代码加载一张网络图片：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>)</span><br><span class="line">        .load(url)</span><br><span class="line">        .into(imgView);</span><br></pre></td></tr></table></figure></p>
<p>上面的三个方法都很眼熟吧，我们之前都已经介绍过了。<br>假设这是我们的 APP 第一次使用 Glide 加载一张图片，那么流程如下：</p>
<p><img src="https://appzy.vip/img/glide_process.png" alt="加载流程"></p>
<p>上面的流程是简化版，省去了一部分东西，可以通过这张图更直观的了解到 Glide 的加载流程以及机制。</p>
<h1 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h1><hr>
<p>根据模块学习事半功倍，先看看 Glide 的分包结构：</p>
<p><img src="https://appzy.vip/img/glide_package.png" alt="包结构"></p>
<p>先看看最外层的几个类。</p>
<h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><hr>
<p>Glide 是<strong>单例类</strong>，通过 Glide#get(Context) 方法可以获取到实例。</p>
<p>Glide 类算是个<strong>全局的配置类</strong>，Encoder、Decoder、ModelLoader、Pool 等等都在这里设置，此外还提供了创建 RequestManager 的接口（Glide#with() 方法）。</p>
<p>使用 Glide 时会最先调用 Glide#with() 方法创建 RequestManager，Glide 中的 with() 方法有五个重载：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestManager <span class="title">with</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">RequestManager <span class="title">with</span><span class="params">(android.app.Activity)</span></span></span><br><span class="line"><span class="function">RequestManager <span class="title">with</span><span class="params">(android.app.Fragment)</span></span></span><br><span class="line"><span class="function">RequestManager <span class="title">with</span><span class="params">(android.support.v4.app.Fragment)</span></span></span><br><span class="line"><span class="function">RequestManager <span class="title">with</span><span class="params">(android.support.v4.app.FragmentActivity)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Glide#with() 方法会将 RequestManager 的创建委托给 RequestManagerRetriever，RequestManagerRetriever 为单例类，调用 get(Context) 创建 RequestManager。</p>
<h2 id="GlideBuilder"><a href="#GlideBuilder" class="headerlink" title="GlideBuilder"></a>GlideBuilder</h2><hr>
<p>GlideBuilder 是用来创建 Glide 实例的类，其中包含了很多个 get/set 方法，例如设置 BitmapPool、MemoryCache、ArrayPool 等等，最终通过这些设置调用 build 方法构建 Glide，可以截取 build 方法中的一段代码来看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//创建 Bitmap 池</span></span><br><span class="line">    <span class="keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//创建数组池</span></span><br><span class="line"><span class="keyword">if</span> (arrayPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">    arrayPool = <span class="keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//创建内存缓存</span></span><br><span class="line"><span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">    memoryCache = <span class="keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//创建磁盘缓存</span></span><br><span class="line"><span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面截取的几行代码很具有代表性，这些数组池、缓存实现等等最终都会当做 Glide 构造器的参数创建 Glide 实例。</p>
<h2 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</h2><hr>
<p>上面说的 5 个重载的 Glide#with() 方法对应 RequestManagerRetriever 中的 5 个重载的 get() 方法。<br>由于这个比较重要，而且跟我们使用息息相关，所以仔细的说一下~</p>
<p>创建 RequestManager 逻辑如下：</p>
<ol>
<li>如果 with 方法的参数为 Activity 或者 Fragment ，则最终调用 RequestManagerRetriever 中的 fragmentGet(Context, android.app.FragmentManager) 方法创建 RequestManager；</li>
<li>如果 with 方法的参数为 android.support.v4.app.Fragment 或者android.support.v4.app.FragmentActivity，则最终调用 supportFragmentGet(Context, android.support.v4.app.FragmentManager) 方法创建 RequestManager；</li>
<li>如果 with 方法的参数为 Context，则会判断其来源是否属于 FragmentActivity 及 Activity，是则按照上面的逻辑进行处理，否则最终调用 getApplicationManager(Context) 方法创建 RequestManager。</li>
</ol>
<p>上面说的情况有个条件都是在主线程调用 Glide#with() 方法， 如果子线程调用 Glide#with()  或者系统版本小于 17，则最终会调用 getApplicationManager(Context) 方法创建 RequestManager 。</p>
<p>也就是说，无论使用什么参数，最终都会进入如下三个方法创建 RequestManager：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm)</span></span>;</span><br><span class="line"><span class="function">RequestManager <span class="title">supportFragmentGet</span><span class="params">(Context context, android.support.v4.app.FragmentManager fm)</span></span>;</span><br><span class="line"><span class="function">RequestManager <span class="title">getApplicationManager</span><span class="params">(Context context)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这三个方法作用都是用来创建 RequestManager，前两个方法主要是用来兼容 support 包中的 FragmentActivity、Fragment。</p>
<p>至于为什么需要传入一个 FragmentManager 参数留在后面说。</p>
<p>此外还有一种情况，即在<strong>子线程</strong>调用 Glide#with() 方法或传入 Context 对象为 ApplicationContext，此时会创建一个全局唯一的 RequestManager，生命周期与 APP 周期保持一致。</p>
<p>根据上述规则可以得出以下几个结论：</p>
<ol>
<li>同一个 Activity 对应一个 FragmentManager，一个 FragmentManager 对应一个 RequestManagerFragment，一个 RequestManagerFragment 对应一个 RequestManager，所以<strong>一个 Activity 对应 一个 RequestManager</strong>；</li>
<li>同一个 Fragment 同样可得出上述结论；</li>
<li>但如果 Fragment 属于 Activity，或者 Fragment 属于 Fragment，在 Activity、Framgnent 中分别创建 Glide 请求是并不会只创建一个 RequestManager；</li>
<li><strong>子线程</strong>发起 Glide 请求或传入对象为 ApplicationContext，则使用全局单例的 RequestManager。</li>
</ol>
<h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><hr>
<p>RequestManager 主要由两个作用：</p>
<ol>
<li>创建 RequestBuilder ；</li>
<li>通过生命周期管理请求的启动结束等。</li>
</ol>
<p>我们都知道使用 Glide 加载图片时，如果当前页面被销毁或者不可见时会停止加载图片，但我们使用 Glide 加载图片时并没有显示的去设置 Glide 与当前页面的生命周期关联起来，只是传了个 Context 对象，那么 Glide 是如何通过一个上下文对象就能获取到页面生命周期的呢？</p>
<p>通过上面 RequestManagerRetriever 章节的介绍我们知道创建 RequestManager 时需要一个 FragmentManager 参数（全局 RequestManager 除外），那么再创建 RequestManager 时会<strong>先创建一个不可见的 Fragment</strong> ，通过 FM 加入到当前页面，用这个不可见的 Fragment 即可检测页面的生命周期。代码中保证了每个 Activity/Fragment 中只包含一个 RequestManagerFragment 与 一个 RequestManager。</p>
<p>创建 RequestBuilder 的 load 方法有很多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Bitmap bitmap)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Uri uri)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable File file)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@RawRes @DrawableRes @Nullable Integer resourceId)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable URL url)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable <span class="keyword">byte</span>[] model)</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable Object model)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>看看有这么多重载方法，没一个都代表不同的加载源。<br>除此之外还有两个特殊的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestBuilder&lt;File&gt; <span class="title">downloadOnly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">RequestBuilder&lt;File&gt; <span class="title">download</span><span class="params">(@Nullable Object model)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这两个听名字就知道是用来下载图片的。</p>
<h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><hr>
<p>RequestBuilder 用来构建请求，例如设置 RequestOption、缩略图、加载失败占位图等等。<br>上面说到的 RequestManager 中诸多的 load 重载方法，同样也对应 RequestBuilder 中的重载 load 方法，一般来说 load 方法之后就是调用 into 方法设置 ImageView 或者 Target，into 方法中最后会创建  Request，并启动，这个后面会详细介绍。</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><hr>
<p>顾名思义， request 包下面的是封装的请求，里面有一个 Request 接口，估计所有的请求都是基于这个接口的，看一下：</p>
<p><img src="https://appzy.vip/img/request_method.png" alt="Request"></p>
<p>接口定义了对请求的开始、结束、状态获取、回收等操作，所以请求中不仅包含基本的信息，还负责管理请求。<br>Request 主要的实现类有三个：</p>
<ol>
<li>SingleRequest</li>
<li>ThumbnailRequestCoordinator</li>
<li>ErrorRequestCoordinator</li>
</ol>
<p>一个个看。</p>
<h3 id="SingleRequest"><a href="#SingleRequest" class="headerlink" title="SingleRequest"></a>SingleRequest</h3><hr>
<p>这个类负责执行请求并将结果反映到 Target 上。</p>
<p>当我们使用 Glide 加载图片时，会先根据 Target 类型创建不同的 Target，然后 RequestBuilder 将这个 target 当做参数创建 Request 对象，Request 与 Target 就是这样关联起来的。</p>
<p>这里就会先创建一个包含 Target 的 SingleRequest 对象。考虑到性能问题，可能会连续创建很多个 SingleRequest 对象，所以使用了对象池来做缓存。<br>再来说说 SingleRequest 的请求发起流程。</p>
<p>我们经常在 Activity#onCreate 方法中直接使用 Glide 方法，但此时的图片大小还未确定，所以调用 Request#begin 时并不会直接发起请求，而是等待 ImageView 初始化完成，对于 ViewTarget 以及其子类来说，会注册View 的 OnPreDrawListener 事件，等待 View 初始化完成后就调用 SingleRequest#onSizeReady 方法，这个方法里就会开始加载图片了。</p>
<p>onSizeReady 方法并不会去直接加载图片，而是调用了 Engine#load 方法加载，这个方法差不多有二十个参数，所以 onSizeReady 方法算是用来构建参数列表并且调用 Engine#load 方法的。</p>
<p>clear 方法用于停止并清除请求，主要就是从 Engine 中移除掉这个任务以及回调接口。<br>另外，SingleRequest 实现了 ResourceCallback 接口，这个接口就连个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(GlideException e)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>即资源加载完成和加载失败的两个回调方法，刚刚说的 Engine#load 方法中有差不多二十个参数，其中有一个参数就是这个接口。那再来说这两个方法在 SingleRequest  中的实现。<br>其实很简单，重点就是调用 Target#onResourceReady 方法以及构建图片加载完成的动画，另外还要通知 ThumbnailRequestCoordinator 图片加载完成。<br>onLoadFailed 方法流程大体上也类似 onResourceReady。<br>那 SingleRequest  就差不多这样了。</p>
<h3 id="ThumbnailRequestCoordinator"><a href="#ThumbnailRequestCoordinator" class="headerlink" title="ThumbnailRequestCoordinator"></a>ThumbnailRequestCoordinator</h3><hr>
<p>这个类是用来<strong>协调两个请求</strong>，因为有的请求需要同时加载原图和缩略图，比如启动这两个请求、原图加载完成后缩略图其实就不需要加载了等等，这些控制都由这个类来操作。<br>RequestBuilder 中会将缩略图和原图的两个 SingleRequest  都交给它，后面再对其操作时都由这个类来同一控制。<br>所以这个类其实没什么太多的功能，就是对两个对象的一个统一个管理协调包装。</p>
<h3 id="ErrorRequestCoordinator"><a href="#ErrorRequestCoordinator" class="headerlink" title="ErrorRequestCoordinator"></a>ErrorRequestCoordinator</h3><hr>
<p>RequestBuilder 的父类 BaseRequestOptions 中有几个 error 的重载方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">error</span><span class="params">(@Nullable Drawable drawable)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">error</span><span class="params">(@DrawableRes <span class="keyword">int</span> resourceId)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>一般地，我们会使用这个方法设置一个加载失败时的填充图，大部分情况下都是一个通过 resource 资源文件中获取到的图片 ID 或者 Drawable。<br>但 RequestBuilder 中还提供了另一个 error 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RequestBuilder&lt;TranscodeType&gt; <span class="title">error</span><span class="params">(@Nullable RequestBuilder&lt;TranscodeType&gt; errorBuilder)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>考虑这样的一个场景，当我们加载失败时我可能希望继续去通过网络或者别的什么加载另一张图片，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load((Object) <span class="keyword">null</span>)</span><br><span class="line">    .error(</span><br><span class="line">        Glide.with(context)</span><br><span class="line">            .load(errorModel)</span><br><span class="line">            .listener(requestListener))</span><br><span class="line">    .submit();</span><br></pre></td></tr></table></figure></p>
<p>当我们这样使用 error 时最终就会创建一个 ErrorRequestCoordinator 对象，这个类的功能类似 ThumbnailRequestCoordinator，其中也没多少代码，主要用来协调 ThumbnailRequestCoordinator 以及 error 中的 Request。</p>
<p>通过上面的介绍就已经对 Request 的作用以及子类有一定的了解了，上面多次提到过 Target 是另一个很重要的概念，下面接着看一下这个类。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><hr>
<p>Target 代表一个<strong>可被 Glide 加载并且具有生命周期的资源</strong>。<br>当我们调用 RequestBuilder#into 方法时会根据传入参数创建对应类型的 Target 实现类。</p>
<p>那么 Target 在 Glide 的整个加载流程中到底扮演者什么样的角色呢？Target 的中文意思为：<strong>目标</strong>，实际上就是指加载完成后的图片应该放在哪， Target 默认提供了很多很有用的实现类，当然我们也可以自定义 Target。</p>
<p>Glide 默认提供了用于放在 ImageView 上的 ImageViewTarget（以及其各种子类）、放在 AppWidget 上的 AppWidgetTarget、用于同步加载图片的 FutureTarget（只有一个实现类：RequestFutureTarget）等等，下面分别来看一下。</p>
<h4 id="CustomViewTarget"><a href="#CustomViewTarget" class="headerlink" title="CustomViewTarget"></a>CustomViewTarget</h4><hr>
<p>这个是抽象类，负责加载 Bitmap、Drawable 并且放到 View 上。</p>
<p>上文提到过，如果在 View 还未初始化完成时就调用了 Glide 加载图片会等待加载完成再去执行 onSizeReady 方法，那如何监听 View 初始化完成呢？<br>CustomViewTarget 就针对这个问题给出了解决方案，其中会调用 View#addOnAttachStateChangeListener 方法添加一个监听器，这个监听器可以监听到 View 被添加到 Widow 以及移除 Window 时的事件，从而更好的管理 Request 生命周期。</p>
<p>另外，构建好的 Request 会通过 View#setTag 方法存入 View 中，后面再通过 View#getTag 方法获取。</p>
<p>但这个抽象类并没有实现类，也没有被使用过，View 相关的 Target 都是继承 ViewTarget 抽象基类，但这个类已经被标记为过期类了，推荐将 ViewTarget 替换成 CustomViewTarget 使用。</p>
<h4 id="ViewTarget"><a href="#ViewTarget" class="headerlink" title="ViewTarget"></a>ViewTarget</h4><hr>
<p>这个类又继承了抽象类 BaseTarget，这个基类里只是实现了 Target 接口的 setRequest 以及 getRequest 方法。<br>ViewTarget 基本上类似 CustomViewTarget ，只是具体的实现上有点不同。</p>
<h4 id="ImageViewTarget"><a href="#ImageViewTarget" class="headerlink" title="ImageViewTarget"></a>ImageViewTarget</h4><hr>
<p>听名字就知道，这是加载到 ImageView 上的 Target，继承了 ViewTarget，同样也是个<strong>抽象类</strong>。</p>
<p>构造器中限定了<strong>必须传入 ImageView 或者其子类</strong>，图片数据加载完成后会回调其中的 onResourceReady 方法，第一步是将图片设置给 ImageView，第二部是判断是否需要使用动画，需要的话就执行动画。</p>
<p>ImageViewTarget 的实现类比较多，总共有 5 个，但内容都很简单，主要用于区分加载的资源时 Bitmap 类型还是 Drawable 类型，这个在构建请求时确定，默认的加载请求最终都是 Drawable 类型，但如果构建请求时调用了 asBitmap  方法那就资源就会被转成 Bitmap 类型，另外一个就是资源使用缩略图展示。</p>
<h4 id="RequestFutureTarget"><a href="#RequestFutureTarget" class="headerlink" title="RequestFutureTarget"></a>RequestFutureTarget</h4><hr>
<p>这是用来同步加载图片的 Target，调用 RequestBuilder#submit 将会返回一个 FutureTarget，调用 get 方法即可获取到加载的资源对象。</p>
<h4 id="AppWidgetTarget"><a href="#AppWidgetTarget" class="headerlink" title="AppWidgetTarget"></a>AppWidgetTarget</h4><hr>
<p>用于将下载的 Bitmap 设置到 RemoteView 上。</p>
<h4 id="NotificationTarget"><a href="#NotificationTarget" class="headerlink" title="NotificationTarget"></a>NotificationTarget</h4><hr>
<p>与 AppWidgetTarget 类似，不同的是这是用来将 Bitmap 设置到 Notification 中的 RemoteView 上。</p>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><hr>
<p>module 包下面的 GlideModel 比较重要，需要详细说一下。</p>
<p>这是用来<strong>延迟设置 Glide 相关参数</strong>的，我们可以通过这个接口使 Glide 在初始化时应用我们的设置，因为 Glide 是单例类，通过这个设置可以保证在 Glide 单例类初始时，所有请求发起之前应用到 Glide。</p>
<p>GlideModel 是个接口，所以代码很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlideModule</span> <span class="keyword">extends</span> <span class="title">RegistersComponents</span>, <span class="title">AppliesOptions</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到该接口被标识已过期，Glide 推荐使用 AppGlideModule 替代，不用管他。</p>
<p>GlideModel 接口本身没有代码内容，但其继承了 RegistersComponents 与 AppliesOptions 接口，先分别看一下这两个接口。</p>
<h3 id="RegistersComponents"><a href="#RegistersComponents" class="headerlink" title="RegistersComponents"></a>RegistersComponents</h3><hr>
<p>这是用来注册 Glide 中一些组件的，这个接口只有一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(@NonNull Context context, @NonNull Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Registry registry)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个方法中提供了一个 Registry 对象，这是用来管理注册 ModelLoader、Encoder、Decoder 等等，具体可以看看 Registry 提供的公开方法。</p>
<h3 id="AppliesOptions"><a href="#AppliesOptions" class="headerlink" title="AppliesOptions"></a>AppliesOptions</h3><hr>
<p>这是用来管理一些 Glide 的参数设置项，同样只有一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个方法提供了一个 GlideBuilder 参数，这是用来构建 Glide 的，我们可以使用 GlideBuilder 对象提供的公开方法做一些设置，例如设置线程池、设置 BitmapPool/ArrayPoll 等等。</p>
<p>那么说完这两个接口，在回过头来看看 GlideModel ，通过上面的描述已经明白 GlideModel 中两个方法的作用了，再来看看如何使用。</p>
<p>Glide 在实例化时会解析 manifest 文件并从中获取 value 为  GlideModule 的 meta-data 配置信息，我们定义好自己的 GlideModule 之后需要在 manifest 文件中进行配置，配置方式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.zhangke.glide.samples.OkHttpGlideModule"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">"GlideModule"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中 OkHttpGlideModule 必须实现 GlideModel 接口。</p>
<p>此外，Glide 默认提供了很多 ModelLoader，基本上可以满足所有场景的使用。<br>ModelLoader 的具体作用与机制后面会详细介绍。</p>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><hr>
<p><img src="https://appzy.vip/img/load_package.png" alt="load"></p>
<p>load 包下面是加载资源的核心，里面的东西很多，也很复杂，所以我先把其中两个比较重要的接口介绍完了在介绍别的。</p>
<h3 id="ModelLoader"><a href="#ModelLoader" class="headerlink" title="ModelLoader"></a>ModelLoader</h3><hr>
<p>类路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bumptech.glide.load.model.ModelLoader</span><br></pre></td></tr></table></figure></p>
<p>工厂接口，用于将任意复杂的数据模型转换为可由 DataFetcher  用于获取模型所代表的资源的数据的具体数据类型。叫他加载器比较合适，用来加载资源的。</p>
<p>除此之外，还允许将图片按照 ImageView 大小按需加载。防止浪费内存。</p>
<p>Glide 初始化时会注册很多个 ModelLoader ，除了Glide 默认提供的之外还会注册用户在 manifest 中配置的 ModelLoader，也就是上面 GlideModel 章节介绍的内容。</p>
<p>ModelLoader 中有两个方法以及一个内部类：LoadData，下来看看这两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(@NonNull Model model, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @NonNull Options options)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(@NonNull Model model)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>buildLoadData 方法除了包含 Model 之外还有宽高以及 Option，所以光看参数列表应该能猜到，加载图片时可以根据需要的宽高以及其他设置做到按需加载。<br>返回的是 LoadData 实例，这个类待会再说。所以这个方法的意义就是通过参数构建一个 LoadData 实例。</p>
<p>handles 方法比较简单，就是用来判断给定模型是不是此加载器可能加载的已识别类型。</p>
<p>至于内部类 LoadData 呢，主要作用就是装了三个东西：</p>
<ol>
<li>用于识别资源唯一性的 Key;</li>
<li>缓存相关的备用 Key 列表</li>
<li>DataFetcher</li>
</ol>
<p>其中 DataFetcher最重要，为什么说它是最重要的呢，因为加载资源的根源就在这里（找了半天终于找到了），例如发起网络请求等等，都在这个里面。<br>那既然说到了 DataFetcher 就在说说它。</p>
<h3 id="DataFetcher"><a href="#DataFetcher" class="headerlink" title="DataFetcher"></a>DataFetcher</h3><hr>
<p>类路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bumptech.glide.load.data.DataFetcher</span><br></pre></td></tr></table></figure></p>
<p>DataFetcher 也是个接口，其中最重要的一个方法就是 loadData，听名字就很重要是吧：<strong>加载数据</strong>。</p>
<p>内部实现就是通过 HttpUrlConnect 发起网络请求，或者打开一个文件，或者使用 AssetManager 打开一个资源等等。。。</p>
<p>加载完成后通过 DataFetcher$DataCallback 接口回调。</p>
<p>DataCallback 中包含两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(@Nullable T data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@NonNull Exception e)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>分别代表数据加载成功或者加载失败回调。</p>
<h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><hr>
<p>Encoder 是个接口，在 Glide 中也是个很重要的概念，用来将给定的数据写入持久性存储介质中（文件）。</p>
<p>其中只有一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Writes the given data to the given output stream and returns True if the write completed</span></span><br><span class="line"><span class="comment">   * successfully and should be committed.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data The data to write.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> file The File to write the data to.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> options The put of options to apply when encoding.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">encode</span><span class="params">(@NonNull T data,</span></span></span><br><span class="line"><span class="function"><span class="params">                 @NonNull File file,</span></span></span><br><span class="line"><span class="function"><span class="params">                 @NonNull Options options)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比较简单，注释写的很清楚了，就是把 data 存入文件中。</p>
<p>数据加载完成之后会先使用 Encoder 将数据存入本地磁盘缓存文件中。<br>同样，Encoder 对应的实现类都是在 Glide 初始化时注册进去的。</p>
<h2 id="ResourceDecoder"><a href="#ResourceDecoder" class="headerlink" title="ResourceDecoder"></a>ResourceDecoder</h2><hr>
<p>与 Encoder 对应，<strong>数据解码器</strong>，用来<strong>将原始数据解码成相应的数据类型</strong>，针对不同的请求实现类都不同，例如通过网络请求最终获取到的是一个 InputStream，经过 ByteBufferBitmapDecoder 解码后再生成一个 Bitmap。</p>
<p>需要指出的是，这里解码时会根绝 option 以及图片大小（如果有的话）按需加载 Bitmap，防止内存的浪费。</p>
<p>与 Encoder 一样，Glide 初始化时会注册很多个类型的 ResourceDecoder 实现类，图片数据获取到之后会根据不同的类型使用对应的解码器对其解码。</p>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><hr>
<p>上面的 Request 中也讲到了 Engine 这个类，可理解为<strong>执行引擎</strong>，算是整个 Glide 的核心发动机。</p>
<p>Engine 负责管理请求以及活动资源、缓存等。主要关注 load 方法，这个方法主要做了如下几件事：</p>
<ol>
<li>通过请求构建 Key；</li>
<li>从活动资源中获取资源（详见缓存章节），获取到则返回；</li>
<li>从缓存中获取资源，获取到则直接返回；</li>
<li>判断当前请求是否正在执行，是则直接返回；</li>
<li>构建 EngineJob 与 DecodeJob 并执行。</li>
</ol>
<p>关于缓存相关的都在缓存章节。下面说说 EngineJob 与 DecodeJob。</p>
<h2 id="EngineJob"><a href="#EngineJob" class="headerlink" title="EngineJob"></a>EngineJob</h2><hr>
<p>这个主要用来执行 DecodeJob 以及管理加载完成的回调，各种监听器，没有太多其他的东西。</p>
<h2 id="DecodeJob"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a>DecodeJob</h2><hr>
<p>负责从缓存或数据源中加载原始数据并通过解码器转换为相应的资源类型（Resource）。DecodeJob 实现了 Runnable 接口，由 EngineJob 将其运行在指定线程池中。</p>
<p>首次加载一张图片资源时，资源加载完成后会先存入到本地缓存文件中，然后再从文件中获取。</p>
<p>上面已经说过，图片的加载最终是通过 DataFetcher 来实现，但是此处并没有直接这么调用，考虑到缓存文件，这里面使用的是 DataFetcherGenerator，其有三个实现类，对应不同的加载方式，这里就不多做介绍了，只需要知道它会根据资源类型去 Glide 中获取已注册的 DataFetcher ，然后<strong>通过 DataFetcher#loadData 方法获取原始数据</strong>，获取完成后使用 Encoder 将数据存入磁盘缓存文件中，同时使用对应的解码器将原始数据转换为相应的资源文件，这样整个流程就差不多结束了。</p>
<h1 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h1><hr>
<p>缓存模块涉及到的东西比较多，比较重要。</p>
<p>关于缓存的获取、数据加载相关的逻辑在 Engine#load 方法中。<br>先来看看缓存流程，流程如下图：</p>
<p><img src="https://appzy.vip/img/cache_porcess.png" alt="cache_process"></p>
<p>全部的缓存流程大致如上图所示。</p>
<p>Glide实例化时会实例化三个缓存相关的类以及一个计算缓存大小的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据当前机器参数计算需要设置的缓存大小</span></span><br><span class="line">MemorySizeCalculator calculator = <span class="keyword">new</span> MemorySizeCalculator(context);</span><br><span class="line"><span class="comment">//创建 Bitmap 池</span></span><br><span class="line"><span class="keyword">if</span> (bitmapPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = calculator.getBitmapPoolSize();</span><br><span class="line">        bitmapPool = <span class="keyword">new</span> LruBitmapPool(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bitmapPool = <span class="keyword">new</span> BitmapPoolAdapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建内存缓存</span></span><br><span class="line"><span class="keyword">if</span> (memoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">    memoryCache = <span class="keyword">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建磁盘缓存</span></span><br><span class="line"><span class="keyword">if</span> (diskCacheFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    diskCacheFactory = <span class="keyword">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外 Engine 中还有一个 ActiveResources 作为第一级缓存。下面分别来介绍一下。</p>
<h2 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h2><hr>
<p>ActiveResources 是<strong>第一级缓存</strong>，表示当前正在活动中的资源。<br>类路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bumptech.glide.load.engine.ActiveResources</span><br></pre></td></tr></table></figure></p>
<p>Engine#load 方法中构建好 Key 之后第一件事就是去这个缓存中获取资源，获取到则直接返回，获取不到才继续从其他缓存中寻找。</p>
<p>当资源加载成功，或者通过缓存中命中资源后都会将其放入 ActivityResources 中，资源被释放时移除出 ActivityResources 。</p>
<p>由于其中的生命周期较短，所以<strong>没有大小限制</strong>。</p>
<p>ActiveResources 中通过一个 Map 来存储数据，数据保存在一个<strong>虚引用</strong>（WeakReference）中。</p>
<p>刚刚说的 activeResource 使用一个 Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; 来存储的，此外还有一个引用队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue;</span><br></pre></td></tr></table></figure></p>
<p>每当向 activeResource 中添加一个 WeakReference 对象时都会将 resourceReferenceQueue 和这个 WeakReference 关联起来，用来跟踪这个 WeakReference 的 gc，一旦这个弱引用被 gc 掉，就会将它从 activeResource 中移除，ReferenceQueue 的具体作用可以自行谷歌，大概就是用来<strong>跟踪弱引用（或者软引用、虚引用）是否被 gc 的。</strong></p>
<p>那么 ReferenceQueue 具体是在何时去判断 WeakReference 是否被 gc 了呢，Handler 机制大家应该都知道，但不知道大家有没有用过 MessageQueue.IdleHandler 这个东东，可以调用 MessageQueue#addIdleHandler 添加一个 MessageQueue.IdleHandler 对象，Handler 会在<strong>线程空闲时调用这个方法</strong>。resourceReferenceQueue 在创建时会创建一个 Engine#RefQueueIdleHandler 对象并将其添加到当前线程的 MessageQueue 中，ReferenceQueue 会在 IdleHandler 回调的方法中去判断 activeResource 中的 WeakReference 是不是被 gc 了，如果是，则将引用从 activeResource 中移除，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessageQueue 中的消息暂时处理完回调</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference ref = (ResourceWeakReference) queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activeResources.remove(ref.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回 true，表示下次处理完仍然继续回调</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MemorySizeCalculator"><a href="#MemorySizeCalculator" class="headerlink" title="MemorySizeCalculator"></a>MemorySizeCalculator</h2><hr>
<p>这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache <strong>大小</strong>的。<br>计算方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认为 4MB，如果是低内存设备则在此基础上除以二</span></span><br><span class="line">arrayPoolSize =</span><br><span class="line">        isLowMemoryDevice(builder.activityManager)</span><br><span class="line">                ? builder.arrayPoolSizeBytes / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">                : builder.arrayPoolSizeBytes;</span><br><span class="line"><span class="comment">//其中会先获取当前进程可使用内存大小，</span></span><br><span class="line"><span class="comment">//然后通过判断是否是否为低内存设备乘以相应的系数，</span></span><br><span class="line"><span class="comment">//普通设备是乘以 0.4，低内存为 0.33，这样得到的是 Glide 可使用的最大内存阈值 maxSize</span></span><br><span class="line"><span class="keyword">int</span> maxSize =</span><br><span class="line">        getMaxSize(</span><br><span class="line">                builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> widthPixels = builder.screenDimensions.getWidthPixels();</span><br><span class="line"><span class="keyword">int</span> heightPixels = builder.screenDimensions.getHeightPixels();</span><br><span class="line"><span class="comment">//计算一张格式为 ARGB_8888 ，大小为屏幕大小的图片的占用内存大小</span></span><br><span class="line"><span class="comment">//BYTES_PER_ARGB_8888_PIXEL 值为 4</span></span><br><span class="line"><span class="keyword">int</span> screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">int</span> targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);</span><br><span class="line"><span class="comment">//去掉 ArrayPool 占用的内存后还剩余的内存</span></span><br><span class="line"><span class="keyword">int</span> availableSize = maxSize - arrayPoolSize;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> (targetMemoryCacheSize + targetBitmapPoolSize &lt;= availableSize) &#123;</span><br><span class="line">    <span class="comment">//未超出内存限制</span></span><br><span class="line">    memoryCacheSize = targetMemoryCacheSize;</span><br><span class="line">    bitmapPoolSize = targetBitmapPoolSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//超出内存限制</span></span><br><span class="line">    <span class="keyword">float</span> part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">    memoryCacheSize = Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">    bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接看上面的注释即可。</p>
<h2 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h2><hr>
<p>Bitmap 是用来<strong>复用 Bitmap</strong> 从而避免重复创建 Bitmap 而带来的内存浪费，Glide 通过 SDK 版本不同创建不同的 BitmapPool 实例，版本低于 Build.VERSION_CODES.HONEYCOMB(11) 实例为 BitmapPoolAdapter，其中的方法体几乎都是空的，也就是是个实例不做任何缓存。<br>否则实例为 LruBitmapPool，先来看这个类。</p>
<h3 id="LruBitmapPool"><a href="#LruBitmapPool" class="headerlink" title="LruBitmapPool"></a>LruBitmapPool</h3><hr>
<p>LruBitmapPool 中没有做太多的事，主要任务都交给了 <strong>LruPoolStrategy</strong>，这里只是做一些缓存大小管理、封装、日志记录等等操作。</p>
<p>每次调用 put 缓存数据时都会调用 trimToSize 方法判断已缓存内容是否大于设定的最大内存，如果大于则使用 LruPoolStrategy#removeLast 方法逐步移除，直到内存小于设定的最大内存为止。</p>
<p>LruPoolStrategy 有两个实现类：SizeConfigStrategy 以及 AttributeStrategy，根据系统版本创建不同的实例，这两个差异不大，KITKAT 之后使用的都是 SizeConfigStrategy，这个比较重要。</p>
<h4 id="SizeConfigStrategy"><a href="#SizeConfigStrategy" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h4><hr>
<p>SizeConfigStrategy 顾名思义，是通过 Bitmap 的 size 与 Config 来当做 key 缓存 Bitmap，Key 也会通过 KeyPool 来缓存在一个队列（Queue）中。</p>
<p>与  AttributeStrategy 相同的是，其中都使用 Glide 内部自定义的数据结构：<strong>GroupedLinkedMap</strong> 来存储 Bitmap。</p>
<p>当调用 put 方法缓存一个 Bitmap 时会先通过 Bitmap 的大小以及 Bitmap.Config 创建（从 KeyPool 中获取）Key，然后将这个 Key 与 Bitmap 按照键值对的方式存入 GroupedLinkedMap  中。</p>
<p>此外其中还包含一个 sortedSizes，这是一个 HashMap，Key 对应 put 进来的 Bitmap.Config，value 对应一个 TreeMap，TreeMap 中记录着每一个 size 的 Bitmap 在当前缓存中的个数，即 put 时加一，get 时减一。</p>
<p>TreeMap 是<strong>有序的</strong>数据结构，当需要通过 Bitmap 的 size 与 Config 从缓存中获取一个 Biamp 时未必会一定要获取到 size 完全相同的 Bitmap，由于 TreeMap 的特性，调用其 ceilingKey 可以获取到一个相等或大于当前 size 的一个最小值，用这个 Key 去获取 Bitmap，然后重置一下大小即可。</p>
<p>重点看一下 GroupedLinkedMap，这是 Glide 为了 实现 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU 算法</a>自定义的一个数据结构，看名字是已分组的链表 Map？看一下下面的图就明白了：</p>
<p><img src="https://appzy.vip/img/grouped_linked_map.png" alt="GroupedLinkedMap"></p>
<p>其中包含三种数据结构：哈希表（HashMap）、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">循环链表</a>以及列表（ArrayList）。<br>这个结构其实类似 Java 里提供的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener">LinkedHashMap</a> 类。</p>
<p>循环链表是通过内部类 GroupedLinkedMap$LinkedEntry 实现的，其中除了定义了链表结构需要的上下两个节点信息之外还包含着一个 Key 与一个 Values，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; values;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; next;</span><br><span class="line">    LinkedEntry&lt;K, V&gt; prev;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是将 HashMap 的 Values 使用<strong>链表</strong>串了起来，每个 Value 中又存了个 <strong>List</strong>。</p>
<p>调用 put 方法时会先根据 Key 去这个 Map 中获取 LinkedEntry，获取不到则创建一个，并且加入到链表的尾部，然后将 value （也就是 Bitmap）存入 LinkedEntry 中的 List 中。</p>
<p>所以这里说的分组指的是通过 Key 来对 Bitmap 进行分组，对于同一个 Key（size 与 config 都相同）的 Bitmap 都会存入同一个 LinkedEntry 中。</p>
<p>调用 get 方法获取 Bitmap 时会先通过 Key 去 keyToEntry 中获取 LinkedEntry 对象，获取不到则创建一个，然后将其加入到链表头部，此时已经有了 LinkedEntry 对象，调用 LinkedEntry#removeLast 方法返回并删除 List 中的最后一个元素。</p>
<p>通过上面两步可以看到之所以使用链表是为了<strong>支持 LRU 算法</strong>，最近使用的 Bitmap 都会移动到链表的前端，使用次数越少就越靠后，当调用  removeLast 方法时就直接调用链表最后一个元素的 removeLast 方法移除元素。</p>
<p>好了 BitmapPool 大概就这么多内容，总结一下：</p>
<ol>
<li>BitmapPool 大小通过 MemorySizeCalculator 设置；</li>
<li>使用 LRU 算法维护 BitmapPool ；</li>
<li>Glide 会根据 Bitmap 的大小与 Config 生成一个 Key；</li>
<li>Key 也有自己对应的对象池，使用 Queue 实现；</li>
<li>数据最终存储在 GroupedLinkedMap 中；</li>
<li>GroupedLinkedMap 使用哈希表、循环链表、List 来存储数据。</li>
</ol>
<h2 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h2><hr>
<p>相比较而言内存缓存就简单多了，如果从上面说的 ActiveResources 中没获取到资源则开始从这里寻找。<br>内存缓存同样使用 <strong>LRU 算法</strong>，实现类为 LruResourceCache，这个类没几行代码，继承了 LruCache ，所以着重看一下 LruCache 好了。</p>
<p>其实 Java 集合里面提供了一个很好的用来实现 LRU 算法的数据结构，即上面提到过的 <strong>LinkedHashMap</strong>。其基于 HashMap 实现，同时又将 HashMap 中的 Entity 串成了一个双向链表。<br>LruCache 中就是使用这个集合来缓存数据，其中代码量也不多，主要就是在 LinkedHashMap 的基础上又提供了对内存的管理的几个操作。</p>
<p>特别地，LruResourceCache 中提供了一个 ResourceRemovedListener 接口，当有资源从 MemoryCache 中被移除时会回调其中的方法，Engine 中接收到这个消息后就会进行 Bitmap 的回收操作。</p>
<h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><hr>
<p>缓存路径默认为 Context#getCacheDir() 下面的 image_manager_disk_cache 文件夹，默认缓存大小为 250MB。</p>
<p>磁盘缓存实现类由 InternalCacheDiskCacheFactory 创建，最终会通过缓存路径及缓存文件夹最大值创建一个 DiskLruCacheWrapper 对象。</p>
<p>DiskLruCacheWrapper 实现了 DiskCache 接口，接口主要的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">File <span class="title">get</span><span class="params">(Key key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Writer writer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到其中提供了作为一个缓存类必须的几个方法，并且文件以 Key 的形式操作。</p>
<p><strong>SafeKeyGenerator</strong> 类用来将 Key 对象转换为字符串，Key 不同的实现类生成 Key 的方式也不同，一般来说会通过图片宽高、加密解码器、引擎等等生成一个 byte[] 然后再转为字符串，以此来保证图片资源的<strong>唯一性</strong>。</p>
<p>另外，在向磁盘写入文件时（put 方法）会使用<strong>重入锁</strong>来同步代码，也就是 DiskCacheWriteLocker 类，其中主要是对 <strong>ReentrantLock</strong> 的包装。</p>
<p>DiskLruCacheWrapper 顾名思义也是一个包装类，包装的是 <strong>DiskLruCache</strong>，那再来看看这个类。</p>
<h3 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h3><hr>
<p>这里考虑一个问题，磁盘缓存同样使用的是 LRU 算法，但文件是存在磁盘中的，如何在 APP 启动之后准确的按照使用次数排序读取缓存文件呢？</p>
<p>Glide 是使用一个<strong>日志清单文件</strong>来保存这种顺序，DiskLruCache 在 APP 第一次安装时会在缓存文件夹下创建一个 <strong>journal</strong> 日志文件来记录图片的添加、删除、读取等等操作，后面每次打开 APP 都会读取这个文件，把其中记录下来的缓存文件名读取到 LinkedHashMap 中，后面每次对图片的操作不仅是操作这个 LinkedHashMap 还要记录在 journal 文件中.</p>
<p>开头的 libcore.io.DiskLruCache 是魔数，用来标识文件，后面的三个 1 是版本号 valueCount 等等，再往下就是图片的操作日志了。</p>
<p>DIRTY、CLEAN 代表操作类型，除了这两个还有 REMOVE 以及 READ，紧接着的一长串字符串是文件的 Key，由上文提到的 SafeKeyGenerator 类生成，是由图片的宽、高、加密解码器等等生成的 SHA-256 散列码 后面的数字是图片大小。</p>
<p>根据这个字符串就可以在同目录下找到对应的图片缓存文件，那么打开缓存文件夹即可看到上面日志中记录的文件</p>
<p>由于涉及到磁盘缓存的外部排序问题，所以相对而言磁盘缓存比较复杂。</p>
<p>那么 Glide 的缓存模块至此就结束了，主要是  BitmapPool 中的数据结构以及磁盘缓存比较复杂，其他的倒也不是很复杂。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr>
<p>至此，Glide 源码分析就结束了，对于像 <a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a> 这种优秀的源码看一遍能学到很多东西，受益匪浅，而且源码是越看越熟，看得多了，再去看别的框架就很简单。</p>
      
    </div>
    
  </div>
  
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/">Glide 源码分析解读-基于Glide 4.9.0</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">appzy</a></p>
        <p><span>发布时间:</span>2016-06-15, 11:25:00</p>
        <p><span>最后更新:</span>2019-06-19, 14:30:47</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/" title="Glide 源码分析解读-基于Glide 4.9.0">http://appzy.vip/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/</a>
            <span class="copy-path" data-clipboard-text="原文: http://appzy.vip/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/　　作者: appzy" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/02/11/设计模式之单例模式/">
                    设计模式之单例模式
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/06/15/可视化正则表达式/">
                    可视化正则表达式整理
                </a>
            </div>
        
    </nav>
  
</article>
<div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#模块介绍"><span class="toc-number">1.</span> <span class="toc-text"><a href="#&#x6A21;&#x5757;&#x4ECB;&#x7ECD;" class="headerlink" title="&#x6A21;&#x5757;&#x4ECB;&#x7ECD;"></a>&#x6A21;&#x5757;&#x4ECB;&#x7ECD;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Glide"><span class="toc-number">1.1.</span> <span class="toc-text"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GlideBuilder"><span class="toc-number">1.2.</span> <span class="toc-text"><a href="#GlideBuilder" class="headerlink" title="GlideBuilder"></a>GlideBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestManagerRetriever"><span class="toc-number">1.3.</span> <span class="toc-text"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestManager"><span class="toc-number">1.4.</span> <span class="toc-text"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestBuilder"><span class="toc-number">1.5.</span> <span class="toc-text"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Request"><span class="toc-number">1.6.</span> <span class="toc-text"><a href="#Request" class="headerlink" title="Request"></a>Request</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SingleRequest"><span class="toc-number">1.6.1.</span> <span class="toc-text"><a href="#SingleRequest" class="headerlink" title="SingleRequest"></a>SingleRequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThumbnailRequestCoordinator"><span class="toc-number">1.6.2.</span> <span class="toc-text"><a href="#ThumbnailRequestCoordinator" class="headerlink" title="ThumbnailRequestCoordinator"></a>ThumbnailRequestCoordinator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ErrorRequestCoordinator"><span class="toc-number">1.6.3.</span> <span class="toc-text"><a href="#ErrorRequestCoordinator" class="headerlink" title="ErrorRequestCoordinator"></a>ErrorRequestCoordinator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Target"><span class="toc-number">1.6.4.</span> <span class="toc-text"><a href="#Target" class="headerlink" title="Target"></a>Target</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CustomViewTarget"><span class="toc-number">1.6.4.1.</span> <span class="toc-text"><a href="#CustomViewTarget" class="headerlink" title="CustomViewTarget"></a>CustomViewTarget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewTarget"><span class="toc-number">1.6.4.2.</span> <span class="toc-text"><a href="#ViewTarget" class="headerlink" title="ViewTarget"></a>ViewTarget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImageViewTarget"><span class="toc-number">1.6.4.3.</span> <span class="toc-text"><a href="#ImageViewTarget" class="headerlink" title="ImageViewTarget"></a>ImageViewTarget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestFutureTarget"><span class="toc-number">1.6.4.4.</span> <span class="toc-text"><a href="#RequestFutureTarget" class="headerlink" title="RequestFutureTarget"></a>RequestFutureTarget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AppWidgetTarget"><span class="toc-number">1.6.4.5.</span> <span class="toc-text"><a href="#AppWidgetTarget" class="headerlink" title="AppWidgetTarget"></a>AppWidgetTarget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NotificationTarget"><span class="toc-number">1.6.4.6.</span> <span class="toc-text"><a href="#NotificationTarget" class="headerlink" title="NotificationTarget"></a>NotificationTarget</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#module"><span class="toc-number">1.7.</span> <span class="toc-text"><a href="#module" class="headerlink" title="module"></a>module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RegistersComponents"><span class="toc-number">1.7.1.</span> <span class="toc-text"><a href="#RegistersComponents" class="headerlink" title="RegistersComponents"></a>RegistersComponents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppliesOptions"><span class="toc-number">1.7.2.</span> <span class="toc-text"><a href="#AppliesOptions" class="headerlink" title="AppliesOptions"></a>AppliesOptions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load"><span class="toc-number">1.8.</span> <span class="toc-text"><a href="#load" class="headerlink" title="load"></a>load</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ModelLoader"><span class="toc-number">1.8.1.</span> <span class="toc-text"><a href="#ModelLoader" class="headerlink" title="ModelLoader"></a>ModelLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataFetcher"><span class="toc-number">1.8.2.</span> <span class="toc-text"><a href="#DataFetcher" class="headerlink" title="DataFetcher"></a>DataFetcher</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Encoder"><span class="toc-number">1.9.</span> <span class="toc-text"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResourceDecoder"><span class="toc-number">1.10.</span> <span class="toc-text"><a href="#ResourceDecoder" class="headerlink" title="ResourceDecoder"></a>ResourceDecoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Engine"><span class="toc-number">1.11.</span> <span class="toc-text"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EngineJob"><span class="toc-number">1.12.</span> <span class="toc-text"><a href="#EngineJob" class="headerlink" title="EngineJob"></a>EngineJob</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DecodeJob"><span class="toc-number">1.13.</span> <span class="toc-text"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a>DecodeJob</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存模块"><span class="toc-number">2.</span> <span class="toc-text"><a href="#&#x7F13;&#x5B58;&#x6A21;&#x5757;" class="headerlink" title="&#x7F13;&#x5B58;&#x6A21;&#x5757;"></a>&#x7F13;&#x5B58;&#x6A21;&#x5757;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ActiveResources"><span class="toc-number">2.1.</span> <span class="toc-text"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MemorySizeCalculator"><span class="toc-number">2.2.</span> <span class="toc-text"><a href="#MemorySizeCalculator" class="headerlink" title="MemorySizeCalculator"></a>MemorySizeCalculator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BitmapPool"><span class="toc-number">2.3.</span> <span class="toc-text"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LruBitmapPool"><span class="toc-number">2.3.1.</span> <span class="toc-text"><a href="#LruBitmapPool" class="headerlink" title="LruBitmapPool"></a>LruBitmapPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SizeConfigStrategy"><span class="toc-number">2.3.1.1.</span> <span class="toc-text"><a href="#SizeConfigStrategy" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MemoryCache"><span class="toc-number">2.4.</span> <span class="toc-text"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘缓存"><span class="toc-number">2.5.</span> <span class="toc-text"><a href="#&#x78C1;&#x76D8;&#x7F13;&#x5B58;" class="headerlink" title="&#x78C1;&#x76D8;&#x7F13;&#x5B58;"></a>&#x78C1;&#x76D8;&#x7F13;&#x5B58;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DiskLruCache"><span class="toc-number">2.5.1.</span> <span class="toc-text"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number">3.</span> <span class="toc-text"><a href="#&#x7ED3;&#x8BED;" class="headerlink" title="&#x7ED3;&#x8BED;"></a>&#x7ED3;&#x8BED;</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>


    <div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Glide 源码分析解读-基于Glide 4.9.0　| appzy　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>



    


<div class="scroll" id="post-nav-button">
        
            <a href="/2017/02/11/设计模式之单例模式/" title="上一篇: 设计模式之单例模式">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/06/15/可视化正则表达式/" title="下一篇: 可视化正则表达式整理">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/jQuery夜晚天空满天星星闪烁动画/">jQuery夜晚天空满天星星闪烁动画（附源码）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Android 接入微信支付宝支付/">Android 接入微信支付宝支付</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/DeviceInfo采集android设备信息工具/">DeviceInfo采集android设备信息工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/25/Android 内存优化/">Android 内存优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/Android代码混淆干货/">Android代码混淆干货</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/26/webview详解和常见的问题/">webview详解和常见的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/Android面试总结/">Android面试总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/Android面试总结(问答)/">Android面试总结(问答篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/11/设计模式之单例模式/">设计模式之单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/Glide 源码分析解读-基于Glide4.9.0/">Glide 源码分析解读-基于Glide 4.9.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/可视化正则表达式/">可视化正则表达式整理</a></li></ul>


    <script>
        
    </script></div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2019 appzy
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架" rel="external nofollow">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5" rel="external nofollow">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    <script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>
<script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide()" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
